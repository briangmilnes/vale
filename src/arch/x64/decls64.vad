include{:verbatim} "vale.i.dfy"
include{:verbatim} "vale64.i.dfy"
include{:verbatim} "../../lib/util/operations.i.dfy"
include "decls.vad"

#verbatim
module x64_decls64_i
{
import opened x64_def_s
import opened x64_vale_i
import opened x64_vale64_i
import opened x64_decls_i
import opened operations_i
#endverbatim

// This must be called before return or C call if one uses XMM registers.
procedure{:refined} {:bridge} {:instruction Ins(EMMS)} EMMS()
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}   

// PUSH_r64 
procedure{:refined} {:bridge} {:instruction Ins(PUSH(src))} PUSH(operand src: uint64) 
  modifies stack;
  requires{:refined false}
           @src is OReg;
           Valid64BitSourceOperand(to_state(this), @src);
           ValidOperand(to_state(this), 64, @src);
  ensures
    let slen := SeqLength(old(stack));
    SeqLength(stack) == 1 + old(SeqLength(stack));
    old(stack) == SeqSlice(stack, 1, slen + 1);
    stack == old(SeqPrepend(make64BitFrame(src), stack));
    inFrame(stack[0], 0);
    inFrame(stack[0], 1);
    stack[0][0] == lower64trans(old(src));
    stack[0][1] == upper64trans(old(src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal lowerUpper64;
    reveal lower64;
    reveal upper64;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}   


procedure {:refined} {:bridge} {:instruction Ins(POP(dst))} POP(inout operand dst: uint64) 
  modifies stack;
  requires 
    SeqLength(stack) > 1;
    HasAtLeastN64BitFrames(stack,1);
    inFrame(stack[0], 0);
    inFrame(stack[0], 1);
  ensures
    let slen := SeqLength(old(stack));
    SeqLength(stack) == slen - 1;
    dst == old(lowerUpper64(stack[0][0],stack[0][1]));
    stack == old(SeqTail(stack,1));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal lowerUpper64;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}   

/* This awaiting a reasonable specification of unsigned multiplication. 
procedure{:refined}  {:bridge} {:instruction Ins(PCLMULQDQ(dst, src, OConst(imm8)))} PCLMULQDQ(inout operand dst: Quadword, operand src:Quadword, inline imm8: uint8)
  requires{:refined false}
           @dst is OReg;
           @src is OReg;
// pg 893
// 0 0 CL_MUL( dst[63:0], src[63:0])
// 0 1 CL_MUL( dst[63:0], src[127:64] )
// 1 0 CL_MUL( dst[127:64], src[63:0] )
// 1 1 CL_MUL( dst[127:64], src[127:64] )
  let src_low := lowerUpper64(old(src).lo, old(src).mid_lo);
  let src_hi  := lowerUpper64(old(src).mid_hi, old(src).hi);
  let dst_low := lowerUpper64(old(dst).lo, old(dst).mid_lo);
  let dst_hi  := lowerUpper64(old(dst).mid_hi, old(dst).hi);
  ensures 
   (!uint8_bit4(imm8) && !uint8_bit0(imm8)) ==> dst == Uint128ToQuadword(CL_MUL(dst_low, src_low))
   (!uint8_bit4(imm8) &&  uint8_bit0(imm8)) ==> dst == Uint128ToQuadword(CL_MUL(dst_low, src_hi))
   ( uint8_bit4(imm8) && !uint8_bit0(imm8)) ==> dst == Uint128ToQuadword(CL_MUL(dst_hi, src_low))
   ( uint8_bit4(imm8) && uint8_bit0(imm8))  ==> dst == Uint128ToQuadword(CL_MUL(dst_hi, src_hi))
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal lowerUpper64;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined}  {:bridge} {:instruction Ins(VPCLMULQDQ(dst, src1, src2, OConst(imm8)))} PCLMULQDQ(inout operand dst: Quadword, operand src1 : Quadword, operand src2 : Quadword, inline imm8: uint8)
  requires{:refined false}
           @dst is OReg;
           @src is OReg;
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal lowerUpper64;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}
*/


procedure{:refined}{:instruction Ins(Div64(src))} Div64(operand src:uint64)
   requires{:refined false}
      @src is OReg;
      src != 0;  
    // OK, we are cheating a bit here by overconstraining DIV instead of using flags.
    // The proofs are valid though.
    modifies rax; rdx;
    ensures
        rax == old(BitwiseDiv128by64(rdx, rax, src)); // Will return 0 on 0 src.
        rdx == old(BitwiseMod128by64(rdx, rax, src)); // Will return 0 on 0 src.
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal BitwiseDiv128by64;
    reveal BitwiseMod128by64;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}   

// Intel assemblers will just look at the register types and do the right thing.
// But Vale wants to know the argument types so needs a special instruction which writes as a MOVD.
procedure{:refined}  {:bridge} {:instruction Ins(MOVD_xmm_rmm32(dst, src))} MOVD_xmm_rmm32(inout operand dst: Quadword, operand src:uint32)
  requires{:refined false}
           @dst is OReg;
           @src is OReg;
           Valid32BitSourceOperand(to_state(this), @src);
           ValidOperand(to_state(this), 32, @src);
  modifies
    efl;
  ensures
    dst == Quadword(old(src), 0, 0, 0);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined}  {:bridge} {:instruction Ins(POR(dst, src))} POR(inout operand dst: Quadword, operand src:Quadword)
  modifies efl;
  ensures
    dst == old(QuadwordOr(dst, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}


procedure{:refined}  {:bridge} {:instruction Ins(MOVDQA(dst, src))} MOVDQA_xmm_xmm(inout operand dst: Quadword, operand src:Quadword)
  requires{:refined false}
      @dst is OReg;
      @src is OReg;
   ensures
    dst == old(src);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined}  {:bridge} {:instruction Ins(VMOVDQA(dst, MakeHeapOp(src, offset, taint)))} 
       VMOVDQA_xmm_m128(inout operand dst: Quadword, operand src: uint64, inline offset : int, inline taint:taint, ghost id:heaplet_id)
    reads
        mem;
    requires{:refined false}
        @dst is OReg;
        @src is OReg;
    requires
        ValidSrcAddr(mem, id, src + offset, 128, taint);
    ensures
        ValidSrcAddr(mem, id, old(src) + offset, 128, taint);
        dst == mem[id].quads[old(src) + offset].v;
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

// PSHUFD and VPSHUFD are different only in DEST[VLMAX-1:128] (Unmodified) vs <- 0 which means that
// if we extend this to a ymm register, VPSHUFD zeros the upper bits but PSHUFD does not.
// So this is identical to PSHUFD at the moment. 
procedure{:refined} {:bridge} {:instruction Ins(VPSHUFD(dst, src, imm8))} 
                     VPSHUFD(inout operand dst: Quadword, operand src:Quadword, operand imm8 : uint8)
  modifies efl;
  ensures
    dst == old(Quadword(select_word(src, byte_to_bits(imm8).lo),
                        select_word(src, byte_to_bits(imm8).mid_lo),
                        select_word(src, byte_to_bits(imm8).mid_hi),
                        select_word(src, byte_to_bits(imm8).hi)));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined}  {:bridge} {:instruction Ins(VPXOR(dst, src1, src2))} VPXOR(inout operand dst: Quadword, operand src1:Quadword, operand src2:Quadword)
  ensures
    dst == old(QuadwordXor(src1, src2));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined} {:bridge} {:instruction Ins(PSLLD(dst, OConst(imm8)))} 
                    PSLLD(inout operand dst: uint64, inline imm8 : uint8)
    modifies
        efl;
    requires
        0 <= imm8 <= 64;
    ensures
        dst == old(BitwiseShl64(dst, imm8));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined}  {:bridge} {:instruction Ins(PSLLDQ(dst, OConst(imm8)))} PSLLDQ(inout operand dst: Quadword, inline imm8 : uint8)
    modifies
        efl;
    requires
        0 <= imm8 <= 16; // Intel does not really require this, just sets it to 16 if it's too big.
    ensures
        dst == old(Uint128ToQuadword(BitwiseShl128(QuadwordToUint128(dst), 8 * imm8)));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined} {:bridge} {:instruction Ins(PSRLD(dst, OConst(imm8)))} 
                    PSRLD(inout operand dst: uint64, inline imm8 : uint8)
    modifies
        efl;
    requires
        0 <= imm8 <= 64;
    ensures
        dst == old(BitwiseShr64(dst, imm8));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined}  {:bridge} {:instruction Ins(PSRLDQ(dst, OConst(imm8)))} PSRLDQ(inout operand dst: Quadword, inline imm8 : uint8)
    modifies
        efl;
    requires
        0 <= imm8 <= 16; // Intel does not really require this, just sets it to 16 if it's too big.
    ensures
        dst == old(Uint128ToQuadword(BitwiseShr128(QuadwordToUint128(dst), 8 * imm8)));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:operand} Mem_in(operand base:int, inline offset:int, inline taint:taint, ghost id:heaplet_id) returns(mem_operand o:int)
    reads
        mem;
    extern;

procedure{:refined}{:bridge}{:instruction Ins(Add64(dst, src))} Add64Wrap(inout operand dst:uint64, mem_operand src:uint64)
    modifies
        efl;
    ensures
        dst == old(BitwiseAdd64(dst, src));
        Cf(efl) == old(dst + src >= 0x1_0000_0000_0000_0000);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal BitwiseAdd64;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
    ghost if (!this.ok)
    {
        this := this.(regs := this.regs[@dst.r := 0]);
    }
}

procedure{:refined}{:bridge} {:instruction Ins(Add64(dst, OConst(1)))} incr64(inout operand dst:uint64)
    modifies
        efl;
    ensures
        dst == old(BitwiseAdd64(dst, 1));
        Cf(efl) == old(dst + 1 >= 0x1_0000_0000_0000_0000);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal BitwiseAdd64;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
    ghost if (!this.ok)
    {
        this := this.(regs := this.regs[@dst.r := 0]);
    }
}

procedure{:refined} {:bridge} {:instruction Ins(MOVQ64XMM(dst, src))} MovLow64To64(out operand dst:uint64, operand src:Quadword)
  ensures
  dst == old(lowerUpper64(src.lo, src.mid_lo));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal lowerUpper64;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
    ghost if (!this.ok)
    {
        this := this.(regs := this.regs[@dst.r := 0]);
    }
}

procedure{:refined}  {:bridge} {:instruction Ins(MOVQXMM64(dst, src))} MovLow64To128(inout operand dst: Quadword, operand src:uint64)
  ensures
    dst == old(Quadword(lower64(src), upper64(src), 0, 0));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal lower64;
    reveal upper64;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

// movhlps  - high 64 to low 64 bit move
procedure{:refined} {:bridge} {:instruction Ins(MOVHLPS(dst, src))}  MOVHLPS(inout operand dst:Quadword, operand src:Quadword)
  ensures
    dst == old(Quadword(src.mid_hi, src.hi, dst.mid_hi, dst.hi));
{
   reveal evalCodeOpaque;
   reveal x86_ValidState;
   this := MaybeUpdateOk(old(this), this);
   this := this.(heaplets := old(this).heaplets);
}

//// movlhps  - low 64 to high 64 bit move
procedure{:refined} {:bridge} {:instruction Ins(MOVLHPS(dst, src))} MOVLHPS(inout operand dst:Quadword, operand src:Quadword)
  ensures
    dst == old(Quadword(dst.lo, dst.mid_lo, src.lo, src.mid_lo));
{
   reveal evalCodeOpaque;
   reveal x86_ValidState;
   this := MaybeUpdateOk(old(this), this);
   this := this.(heaplets := old(this).heaplets);
}

procedure{:refined}{:bridge}{:instruction Ins(Mov64(dst, MakeHeapOp(src, offset, taint)))} Load64(
    out operand dst:uint64,
        operand src:uint64,
        inline offset:int,
        inline taint:taint,
        ghost id:heaplet_id)
    reads
        mem;
    requires{:refined false}
        @dst is OReg;
        @src is OReg;
    requires
        ValidSrcAddr(mem, id, src + offset, 64, taint);
    ensures
        ValidSrcAddr(mem, id, old(src) + offset, 64, taint);
        dst == mem[id].mem64[old(src) + offset].v;
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
    ghost if (!this.ok)
    {
        this := this.(regs := this.regs[@dst.r := 0]);
    }
}

procedure{:refined}{:bridge}{:instruction Ins(Mov64(MakeHeapOp(dst, offset, taint), src))} Store64(
    operand dst:uint64,
    operand src:uint64,
    inline offset:int,
    inline taint:taint,
    ghost id:heaplet_id)
    modifies
        mem;
    requires{:refined false}
        @dst is OReg;
        @src is OReg;
    requires/ensures
        ValidDstAddr(mem, id, dst + offset, 64);
    ensures
        mem == old(mem)[id := old(mem)[id].(mem64 := old(mem)[id].mem64[dst + offset := Heaplet64Entry(src, taint)])];
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    ghost var v := old(src);

    ghost if (old(this).ok) { 
        ghost if (exists id :: ValidDstAddr(old(this).heaplets, id, old(dst) + offset, 64)) {
            exists id :: ValidDstAddr(old(this).heaplets, id, old(dst) + offset, 64);
            this := this.(heaplets := UpdateHeaplets64(old(this), dst + offset, id, taint, v));
            lemma_HeapletsUpdatedCorrectly64(old(this), this, dst + offset, id, taint, v);
        } else {
            this := old(this).(ok := false);
        }
    } else {
      this := old(this);
    }
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined}{:bridge}{:instruction Ins(AddLea64(dst, src1, src2))} AddLea64(out operand dst:uint64, operand src1:uint64, operand src2:uint64)
    requires
        src1 + src2 < 0x1_0000_0000_0000_0000;
    ensures
        dst == old(src1) + old(src2);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure{:refined}{:bridge}{:instruction Ins(Sub64(dst, src))} Sub64(inout operand dst:uint64, operand src:uint64)
    requires
        0 <= dst - src;
    modifies 
        efl;
    ensures
        dst == old(dst) - old(src);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure{:refined}{:bridge}{:instruction Ins(Sub64(dst, src))} Sub64Wrap(inout operand dst:uint64, operand src:uint64)
    modifies
        efl;
    ensures
        dst == old(BitwiseSub64(dst, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal BitwiseSub64;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure{:refined}{:bridge}{:instruction Ins(AddCarry64(dst, src))} Adc64Wrap(inout operand dst:uint64, mem_operand src:uint64)
    modifies
        efl;
    ensures
        dst == old(BitwiseAdd64(BitwiseAdd64(dst, src), if Cf(efl) then 1 else 0));
        Cf(efl) == old(dst + src + (if Cf(efl) then 1 else 0) >= 0x1_0000_0000_0000_0000);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal BitwiseAdd64;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
    lemma_BitwiseAdd64EquivalentToAddMod2To64(old(dst), old(src));
}

procedure{:refined}{:instruction Ins(IMul64(dst, src))} IMul64Wrap(inout operand dst:uint64, operand src:uint64)
    modifies
        efl;
    ensures
        dst == old(BitwiseMul64(dst, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal BitwiseMul64;
    reveal BitwiseMul64hi;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure{:refined}{:instruction Ins(Mul64(src))} Mul64Wrap(operand src:uint64)
    modifies
        efl;
        rax;
        rdx;
    ensures
        rax == old(BitwiseMul64(rax, src));
        rdx == old(BitwiseMul64hi(rax, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal BitwiseMul64;
    reveal BitwiseMul64hi;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure{:refined}{:bridge}{:instruction Ins(And64(dst, src))} And64(inout operand dst:uint64, operand src:uint64)
    modifies
        efl;
    ensures
        dst == old(BitwiseAnd64(dst, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure{:refined}{:bridge}{:instruction Ins(Shl64(dst, src))} Shl64(inout operand dst:uint64, operand src:uint64)
    modifies
        efl;
    requires{:refined false}
        @src is OConst || @src == OReg(X86Ecx);
    requires
        0 <= src < 64;
    ensures
        dst == old(BitwiseShl64(dst, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure{:refined}{:bridge}{:instruction Ins(Shr64(dst, src))} Shr64(inout operand dst:uint64, operand src:uint64)
    modifies
        efl;
    requires{:refined false}
        @src is OConst || @src == OReg(X86Ecx);
    requires
        0 <= src < 64;
    ensures
        dst == old(BitwiseShr64(dst, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

#verbatim
} // end module
#endverbatim
