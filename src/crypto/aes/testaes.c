#include <stdio.h>
#include <string.h> // for memcmp
#include "gcc_compat.h"
#include "aes.h"
#include <stdint.h> // for uint?_t

const uint8_t  key[] = { 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA };
const uint8_t in[]  =  { 0x01, 0x4B, 0xAF, 0x22, 0x78, 0xA6, 0x9D, 0x33, 0x1D, 0x51, 0x80, 0x10, 0x36, 0x43, 0xE9, 0x9A };
const uint8_t out[] =  { 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD};

void demo()
{
  uint8_t buffer[16];
  uint8_t expanded_key[176];

  KeyExpansionStdcall(key, expanded_key);
  AES128EncryptOneBlockStdcall(buffer, in, expanded_key);

  if (memcmp(out, buffer, sizeof(buffer)) == 0) {
      printf("AES128 demo success\n");
  } else {
      printf("AES128 demo failure\n");
  }
}

void print128BitVectorHexBE(const uint8_t v[16]) {
  printf("{");
  for (int i = 15; i >= 0; --i) {
    printf(" 0x%2x",v[i]);
  }
  printf("}\n");
}

void print128BitVectorHexLE(const uint8_t v[16]) {
  printf("{");
  for (int i = 0; i < 16; ++i) {
    printf(" 0x%2x",v[i]);
  }
  printf("}\n");
}

// http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf F.1.1
//Block #1  
//Plaintext      6bc1bee22e409f96e93d7e117393172a  
//Output Block   3ad77bb40d7a3660a89ecaf32466ef97  
//Block #2  
//Plaintext      ae2d8a571e03ac9c9eb76fac45af8e51  
//Output Block   f5d3d58503b9699de785895a96fdbaaf  
//Block #3  
//Plaintext      30c81c46a35ce411e5fbc1191a0a52ef  
//Output Block   43b1cd7f598ece23881b00e3ed030688  
//Block #4  
//Plaintext      f69f2445df4f9b17ad2b417be66c3710  
//Output Block   7b0c785e27e8ad3f8223207104725dd4  

const uint8_t key2[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };
const uint8_t pt[4][16] =
  {
    { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},
    { 0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51},
    { 0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef},
    { 0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10},
  };

const uint8_t ob[4][16] = 
  {
   { 0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97},
   { 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf},
   { 0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88},  
   { 0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4},
   
  };

// https://pdfs.semanticscholar.org/114a/4222c53f1a6879f1a77f1bae2fc0f8f55348.pdf
// The zero key, zero PT TEST 2 pg 28, so it's little endian and AES_128.

const uint8_t key_zero[16] = 
  { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};

const uint8_t pt_zero[11][16] =
  {
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01},
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x02},
    // This is to devise a GCTR test of zero key, these are IV+CTRs that would be encrypted.
    // The plain text in that test is zero so the xor yields the encrypted IV+CTRs.
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x02},
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x03},
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x04},
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x05},
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x06},
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x07},
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x08},
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x09},
    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10}
  };

const uint8_t ob_zero[11][16] = 
{
 { 0x58, 0xe2, 0xfc, 0xce, 0xfa, 0x7e, 0x30, 0x61, 0x36, 0x7f, 0x1d, 0x57, 0xa4, 0xe7, 0x45, 0x5a},    
 { 0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78},
 { 0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78},
 { 0xf7, 0x95, 0xaa, 0xab, 0x49, 0x4b, 0x59, 0x23, 0xf7, 0xfd, 0x89, 0xff, 0x94, 0x8b, 0xc1, 0xe0},
 { 0x20, 0x02, 0x11, 0x21, 0x4e, 0x73, 0x94, 0xda, 0x20, 0x89, 0xb6, 0xac, 0xd0, 0x93, 0xab, 0xe0},
 { 0xc9, 0x4d, 0xa2, 0x19, 0x11, 0x8e, 0x29, 0x7d, 0x7b, 0x7e, 0xbc, 0xbc, 0xc9, 0xc3, 0x88, 0xf2},
 { 0x8a, 0xde, 0x7d, 0x85, 0xa8, 0xee, 0x35, 0x61, 0x6f, 0x71, 0x24, 0xa9, 0xd5, 0x27, 0x02, 0x91},
 { 0x95, 0xb8, 0x4d, 0x1b, 0x96, 0xc6, 0x90, 0xff, 0x2f, 0x2d, 0xe3, 0x0b, 0xf2, 0xec, 0x89, 0xe0},
 { 0x02, 0x53, 0x78, 0x6e, 0x12, 0x65, 0x04, 0xf0, 0xda, 0xb9, 0x0c, 0x48, 0xa3, 0x03, 0x21, 0xde},
 { 0x33, 0x45, 0xe6, 0xb0, 0x46, 0x1e, 0x7c, 0x9e, 0x6c, 0x6b, 0x7a, 0xfe, 0xdd, 0xe8, 0x3f, 0x40},
 { 0x58, 0xb2, 0x43, 0x1b, 0xc0, 0xbe, 0xde, 0x02, 0x55, 0x0f, 0x40, 0x23, 0x89, 0x69, 0xec, 0x78}
};

void test(int length, const uint8_t key[16], const uint8_t in[][16], const uint8_t out[][16])
{
  uint8_t expanded_key[176];

  KeyExpansionStdcall(key, expanded_key);
  for (int i = 0; i < length; ++i) {
    uint8_t output[16];
    memset(output, 0, 16);
    AES128EncryptOneBlockStdcall(output, in[i], expanded_key);

    if (memcmp(out[i], output, sizeof(output)) == 0) {
      printf("AES128 2 success %d\n", i);
    } else {
      printf("AES128 2 failure %d\n", i);
      print128BitVectorHexLE(output);
    }
  }
}

int __cdecl main(void)
{
  demo();
  //  test(4, key2, pt, ob);
  test(11, key_zero, pt_zero, ob_zero);
  return 0;
}
