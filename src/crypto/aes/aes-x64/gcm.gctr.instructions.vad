include "../../../arch/x64/decls.vad"
include "../../../arch/x64/decls64.vad"
include{:verbatim} "../../../arch/x64/print.s.dfy"
include{:verbatim} "../../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "../../../lib/util/words_and_bytes.i.dfy"
include{:verbatim} "../../../lib/util/operations.i.dfy"

include "../../loopunroll/regions128wrappers.vad"

include{:verbatim} "gcm_helpers.i.dfy"
include{:verbatim} "../gcm3.s.dfy"

#verbatim
module GCMGCTRInstructions {

import opened GCMModule
import opened GCMHelpers
import opened x64_decls_i
import opened x64_decls64_i
import opened regions128wrappers

#endverbatim


// This lets us pass in constant small increments for the unrolling.
procedure {:refined} {:bridge} AddN32(inout operand dst : uint32, inline src : uint32)
    modifies efl;
    requires {:refined false} op32(this, @dst);
    requires 0 <= src < 0x1_0000_0000;
    requires 0 <= dst < 0x1_0000_0000;
    requires dst + src < 0x1_0000_0000;
    ensures  dst == BitwiseAdd32(old(dst), src);
    ensures  dst == old(dst) + src;
    ensures  dst < 0x1_0000_0000;
    ensures {:refined false} op32(this, @dst); // It's as if dst loses its opness.
{
   lemma_BitwiseAdd32();
   Add32(dst, src);
} 

procedure LoadArray128'(out operand dst:Quadword, operand src:uint64, inline i:int,
    inline taint:taint, ghost id:heaplet_id)
    reads mem;
    modifies efl;
    requires/ensures
        mem?[id];
        mem[id] is QuadwordHeaplet;
        mem[id].quads?[addr128(old(src), i)];
        mem[id].quads[addr128(old(src), i)].t == taint;
    ensures
        dst == mem[id].quads[addr128(old(src), i)].v;
{
    Load128'(dst, src, 16 * i, taint, id);
}

procedure {:instruction Ins(BSwap32(dst))} BSwap32'(inout operand dst:uint32)
  requires op32(this, @dst);
  ensures op32(this, @dst);
  ensures
    dst == bswap32(old(dst));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

#verbatim
} 
#endverbatim
