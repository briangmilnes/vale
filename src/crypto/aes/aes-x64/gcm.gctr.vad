include "gcm.gctr.aesgctr1.vad"

#verbatim
module GCMGCTR {
 import opened GCMGCTRAESGCTR1
#endverbatim
/*
// DUMMY
procedure {:recursive} {:timeLimitMultiplier 10} AESGCTRUnrolled'
         (ghost old_mem : Heaplets, 
          ghost g: GCMSpec,
          ghost off : uint64, 
          inline step : uint32)

    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    // Use uint64s which are truncated in instructions as uint32s cause problems.
//    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    reads    exp_key_ptr; iptr; iendptr; optr; ivptr; ctr;
    modifies mem; efl; 
//             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
//             tmp32_1; tmp32_2;  tmp32_3;  tmp32_4;  tmp32_5;  tmp32_6;  tmp32_7;  tmp32_8; 

    requires
       step < (iendptr - iptr) / 16;
       0 <= step < 8; 
       0 <= ctr + step < 0x1_0000_0000;
       ValidDstReg128(old_mem, g.iheap, g.iaddr, g.isize);

    requires/ensures 
        GCMSpecDyn(g, exp_key_ptr, ivptr, mem);
        ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, g.isize, Secret, iptr, off, step);
        ValidDstRegPtrs128(mem, g.oheap, g.oaddr, g.isize,         optr, off, step);
        WritesReg128(mem, g.oheap, g.oaddr, g.isize, off,         Public, AESGCTRSeq(old_mem, g, g.isize));

    ensures
         OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
         OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
         // This means I wrote off + step + 1 of the output in total.
         WritesReg128(mem, g.oheap, g.oaddr, g.isize, off + step + 1, Public, AESGCTRSeq(old_mem, g, g.isize));
         ctr == old(ctr);
         iptr == old(iptr);
         iendptr == old(iendptr);
         optr == old(optr);
{
  assume OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
  assume OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
  assume WritesReg128(mem, g.oheap, g.oaddr, g.isize, off + step + 1, Public, AESGCTRSeq(old_mem, g, g.isize));
  assume ctr == old(ctr);
  assume iptr == old(iptr);
  assume iendptr == old(iendptr);
  assume optr == old(optr);
} 
*/

// We can't use operands into here due to the inability to timely prove their inequalty with registers.
procedure {:recursive} {:timeLimitMultiplier 10} AESGCTRUnrolled
         (ghost g: GCMSpec,
          ghost off : uint64, 
          inline step : uint32)

    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    // Use uint64s which are truncated in instructions as uint32s cause problems.
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    reads    exp_key_ptr; iptr; iendptr; optr; ivptr; ctr;
    modifies mem; efl; 
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
             tmp32_1; tmp32_2;  tmp32_3;  tmp32_4;  tmp32_5;  tmp32_6;  tmp32_7;  tmp32_8; 

    requires
       step < (iendptr - iptr) / 16;
       0 <= step < 8; 
       0 <= ctr + step < 0x1_0000_0000;
       ValidDstReg128(mem, g.iheap, g.iaddr, g.isize);

    requires/ensures 
        GCMSpecDyn(g, exp_key_ptr, ivptr, mem);
        ctr == 2 + off;
        ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, g.isize, Secret, iptr, off, step);
        ValidDstRegPtrs128(mem, g.oheap, g.oaddr, g.isize,         optr, off, step);
        WritesReg128(mem, g.oheap, g.oaddr, g.isize, off,         Public, AESGCTRSeq(old(mem), g, g.isize));


    ensures
         OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
         OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
         // This means I wrote off + step + 1 of the output in total.
         WritesReg128(mem, g.oheap, g.oaddr, g.isize, off + step + 1, Public, AESGCTRSeq(old(mem), g, g.isize));
         ctr == old(ctr);
         iptr == old(iptr);
         iendptr == old(iendptr);
         optr == old(optr);
{
  inline if (step == 7) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_8, xmm13, xmm14);
  } else if (step == 6) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_7, xmm12, xmm13);
  } else if (step == 5) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_6, xmm10, xmm11);
  }  else if (step == 4) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_5, xmm8, xmm9);
  } else if (step == 3) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_4, xmm6, xmm7); 
  } else if (step == 2) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_3, xmm4, xmm5);
  } else if (step == 1) {
       assert 0 <= ctr + step < 0x1_0000_0000;
       AESGCTRUnrolled(g, off, step - 1);
       assert 0 <= ctr + step < 0x1_0000_0000;
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_1, xmm2, xmm3);
   } else  if (step == 0) {                                    
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_2, xmm0, xmm1);
   }
}  

procedure {:timeLimitMultiplier 3} AESGCTRLoopOverUnrolled
          (ghost g : GCMSpec,
           inline n : uint8nonzero)
    lets exp_key_ptr @=rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;
    lets items := (old(iendptr) - old(iptr)) / 16;

    reads    exp_key_ptr; ivptr;
    modifies iptr; iendptr; optr; ctr;
    modifies mem; efl; 
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
             tmp32_1; tmp32_2; tmp32_3; tmp32_4; tmp32_5; tmp32_6; tmp32_7; tmp32_8; 
    requires
      ValidDstReg128(old(mem), g.iheap, g.iaddr, g.isize);
      0 < n <= 8;
      (iendptr - iptr) % (n * 16) == 0;
      ctr == 2;
      iptr == g.iaddr;
      iendptr == g.iendaddr;
      optr == g.oaddr;
      items < 0x1_0000_0000 - 2;
      ctr + n < 0x1_0000_0000_0000_0000;
      items == g.isize;

    requires/ensures
        GCMSpecDyn(g, exp_key_ptr, ivptr, mem);
        g.iaddr != g.oaddr;
        ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
        ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
      iendptr == old(iendptr);
      exp_key_ptr == old(exp_key_ptr);
      ctr == old(ctr) + items;
      iptr == iendptr;

      OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
      OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
      WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
    ghost var off   : uint32 := 0;
    lemma_regdiff_loop_ge_uint128(iendptr, iptr, n);
    while (iptr < iendptr)
        invariant
            GCMSpecDyn(g, exp_key_ptr, ivptr, mem);
            iendptr == old(iendptr);
            exp_key_ptr == old(exp_key_ptr);
        
            ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
            ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

            0 <= off <= items;
            off == items - (iendptr - iptr) / 16;
            iptr == g.iaddr + 16 * off;
            optr == g.oaddr + 16 * off;
            ctr == 2 + off;

            (iptr < iendptr) ==> n <= items;
            (iptr < iendptr) ==> items >= 1; // Interesting that it can't prove this on entry wo ==>.
            (iptr < iendptr) ==> (iendptr - iptr) % (n * 16) == 0;
            (iptr < iendptr) ==> (iendptr - iptr) >= (n * 16); // lemma above

            (iptr < iendptr) ==> 0 <= off + n - 1 < items;
            (iptr < iendptr) ==> 0 <= n - 1 < (iendptr - iptr) / 16;
            (iptr < iendptr) ==> ctr + n       < 0x1_0000_0000_0000_0000;
            (iptr < iendptr) ==> optr + n * 16 < 0x1_0000_0000_0000_0000;
            (iptr < iendptr) ==> iptr + n * 16 < 0x1_0000_0000_0000_0000;

            (off < items) ==> ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, items, Secret, iptr, off, n - 1);
            (off < items) ==> ValidDstRegPtrs128(mem, g.oheap, g.oaddr, items,         optr, off, n - 1);
            OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
            OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
// Proves wo writes @3, so the time is going into the AESGCTR call or the writes.
// Bug was not old(mem) in AESGCTRSeq, perhaps I should pass it in?
            WritesReg128(mem, g.oheap, g.oaddr, g.isize, off, Public, AESGCTRSeq(old(mem), g, g.isize));
// Bryan does not use a real one.
//            decreases (iptr - iptr);
          decreases (iendptr - iptr);
    {
//        assume 0 <= ctr + n - 1 < 0x1_0000_0000;
        ghost var mem1 := mem;
        ghost var old_off := off;
        AESGCTRUnrolled(g, off, n - 1);
        ghost var old_iptr := iptr;
        Add(iptr, const(n * 16));        
        Add(optr, const(n * 16));
        Add(ctr, const(n));
        off := off + n;
//        assume (old_iptr < iendptr) ==> (iendptr - old_iptr) % (n * 16) == 0;
//        step_ptrs(g, n, old_iptr, iptr, iendptr);
//        step_writes(old(mem), mem1, mem, g, old_off, off, n);
    }
  assert items == off;
  assert iendptr - iptr == 0;
}

// Encrypt, gctr only with the stack saved and the arguments in the expected place.
/*
procedure AES128GCTREncrypt1(ghost g : GCMSpec)
    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    reads    exp_key_ptr; ivptr; 
    modifies iptr; iendptr; optr; ctr;
    modifies mem; efl; 
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
             tmp32_1; tmp32_2;  tmp32_3;  tmp32_4;  tmp32_5;  tmp32_6;  tmp32_7;  tmp32_8; 

    requires
      GCMSpecDyn(g, exp_key_ptr, ivptr, mem);
      (iendptr - iptr) % (1 * 16) == 0;
      ValidDstReg128(old(mem), g.iheap, g.iaddr, g.isize);

    requires/ensures
       ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
       ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
       WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
  AESGCTRLoopOverUnrolled(old(mem), g,1);
} 
*/

/*
// Setup just the GCM CTR mode from a standard call.
//
// All MM registers are: rax, rbx, rcx, iendptr, rbp, rsi, rdi, rsp, r8, r9, r10, r11, r12, r13, r14, r15.
// 
// GCC is giving us:
// exp_key      - rdi 
// iptr         - rsi
// iendptr      - iendptr
// optr         - rcx
// IV           - r8d
// TO BE ADDED // AAD          - r9d 
// TO BE ADDED // TAG          - r10d - the mac, called TAG by some of the tests. Will this be on the stack?
//
// callee save restore frees up everything for us but:
// We need a 32 bit counter, which we'll put in rax.
// As rsp is the stack pointer, and a frame pointer, rbp may be in use.
// Leaving us: rax, rbx, r9, r10, r11, r12, r13, r14, r15.

// As we'd like to be able to unroll up to 8 way and we need 1 32 bit tmp counter per
// GCTR unfolding, we need up to 8 32 bit temporary registers: 
//
// We need a 96 bit IV in memory, 128 bit, zeros for the last 32, pointed to by r10;
// Then each unrolling gets two xmm registers for an eight way unrolling.
// The temporary registers will be supplied by name to all but final routine.
//
// Thus we own 100% of the 64 and 128 bit registers. 

procedure {:timeLimitMultiplier 3} AES128GCTREncryptStdcall1(ghost g : GCMSpec)
    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    // We OWN the machine, note that rsp is stack in this model.
    modifies mem; efl; 
             rax; rbx; rcx; rdx; rbp; rsi; rdi; stack; r8; r9; r10; r11; r12; r13; r14; r15;
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;

    requires
      GCMSpecDynInit(g, exp_key_ptr, ivptr, mem);
      (iendptr - iptr) % (1 * 16) == 0;
      HasAtLeastFrames(stack, 1);

    requires/ensures
       ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
       ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
       WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
 CalleeSaveLinux();
 // Initialize CTR.
 // Y0 is 1, Y1 the first one E(K,Y1) xor'd with P1, no P0 in the spec.
 Mov32(rax,const(2));
 AES128GCTREncrypt1(g);
 CalleeRestoreLinux();
 EMMS(); // Intel says call this before a return if you are touching XMM.
}

procedure {:timeLimitMultiplier 3} AES128GCTRDecryptStdcall1(ghost g : GCMSpec)
    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    // We OWN the machine, note that rsp is stack in this model.
    modifies mem; efl; 
             rax; rbx; rcx; rdx; rbp; rsi; rdi; stack; r8; r9; r10; r11; r12; r13; r14; r15;
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;

    requires
      GCMSpecDynInit(g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, 0, mem);
      (iendptr - iptr) % (1 * 16) == 0;
      HasAtLeastFrames(stack, 1);

    requires/ensures
       ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
       ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
       WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
 CalleeSaveLinux();
 // Initialize CTR.
 // Y0 is 1, Y1 the first one E(K,Y1) xor'd with P1, no P0 in the spec.
 Mov32(rax,const(2));
 AES128GCTREncrypt1(g);
 CalleeRestoreLinux();
 EMMS(); // Intel says call this before a return if you are touching XMM.
 Mov32(rax, const(0)); // Send back success by default until GHASH is done.
}
*/
#verbatim
}
#endverbatim

