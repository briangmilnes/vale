include "gcm.gctr.proven.vad"

#verbatim
module GCM_GCTR {
 import opened GCM_GCTR_PROVEN
#endverbatim

procedure {:timeLimitMultiplier 10} AESGCTRLoopOverUnrolled
          (ghost g : GCMSpec,
           inline n : uint8nonzero)
    lets exp_key_ptr @=rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;
    lets items := (old(iendptr) - old(iptr)) / 16;

    reads    exp_key_ptr; ivptr;
    modifies iptr; iendptr; optr; ctr;
    modifies mem; efl; 
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
             tmp32_1; tmp32_2; tmp32_3; tmp32_4; tmp32_5; tmp32_6; tmp32_7; tmp32_8; 
    requires
      ValidDstReg128(old(mem), g.iheap, g.iaddr, g.isize);
      0 < n <= 8;
      (iendptr - iptr) % (n * 16) == 0;
      ctr == 2;
      iptr == g.iaddr;
      iendptr == g.iendaddr;
      optr == g.oaddr;
      items < 0x1_0000_0000 - 2;
      ctr + n < 0x1_0000_0000_0000_0000;
      items == g.isize;

    requires/ensures
        GCMSpecDyn(g, exp_key_ptr, ivptr, mem);
        g.iaddr != g.oaddr;
        ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
        ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
      iendptr == old(iendptr);
      exp_key_ptr == old(exp_key_ptr);
      ctr == old(ctr) + items;
      iptr == iendptr;

      OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
      OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
      WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
    ghost var off   : uint32 := 0;
    lemma_regdiff_loop_ge_uint128(iendptr, iptr, n);
    while (iptr < iendptr)
        invariant
            GCMSpecDyn(g, exp_key_ptr, ivptr, mem);
            iendptr == old(iendptr);
            exp_key_ptr == old(exp_key_ptr);
        
            ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
            ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

            0 <= off <= items;
            off == items - (iendptr - iptr) / 16;
            iptr == g.iaddr + 16 * off;
            optr == g.oaddr + 16 * off;
            ctr == 2 + off;

            (iptr < iendptr) ==> // no improvement on a single guard.
             (n <= items &&
             items >= 1 && // Interesting that it can't prove this on entry wo ==>.
             (iendptr - iptr) % (n * 16) == 0 &&
             (iendptr - iptr) >= (n * 16) && // lemma above
             0 <= off + n - 1 < items &&
             0 <= n - 1 < (iendptr - iptr) / 16 &&
             ctr + n       < 0x1_0000_0000_0000_0000 &&
             optr + n * 16 < 0x1_0000_0000_0000_0000 &&
             iptr + n * 16 < 0x1_0000_0000_0000_0000);

            (off < items) ==> ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, items, Secret, iptr, off, n - 1);
            (off < items) ==> ValidDstRegPtrs128(mem, g.oheap, g.oaddr, items,         optr, off, n - 1);
            OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
            OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
            WritesReg128(mem, g.oheap, g.oaddr, g.isize, off, Public, AESGCTRSeq(old(mem), g, g.isize));
          decreases (iendptr - iptr);
    {
        AESGCTRUnrolled(g, off, n - 1);
        ghost var old_iptr := iptr;
        Add(iptr, const(n * 16));        
        Add(optr, const(n * 16));
        Add(ctr, const(n));
        off := off + n;
//        assume (old_iptr < iendptr) ==> (iendptr - old_iptr) % (n * 16) == 0;
//        step_ptrs(g, n, old_iptr, iptr, iendptr);
//        step_writes(old(mem), mem1, mem, g, old_off, off, n);
    }
  assert items == off;
  assert iendptr - iptr == 0;
}

// Encrypt, gctr only with the stack saved and the arguments in the expected place.
/*
procedure AES128GCTREncrypt1(ghost g : GCMSpec)
    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    reads    exp_key_ptr; ivptr; 
    modifies iptr; iendptr; optr; ctr;
    modifies mem; efl; 
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
             tmp32_1; tmp32_2;  tmp32_3;  tmp32_4;  tmp32_5;  tmp32_6;  tmp32_7;  tmp32_8; 

    requires
      GCMSpecDyn(g, exp_key_ptr, ivptr, mem);
      (iendptr - iptr) % (1 * 16) == 0;
      ValidDstReg128(old(mem), g.iheap, g.iaddr, g.isize);

    requires/ensures
       ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
       ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
       WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
  AESGCTRLoopOverUnrolled(old(mem), g,1);
} 
*/

/*
// Setup just the GCM CTR mode from a standard call.
//
// All MM registers are: rax, rbx, rcx, iendptr, rbp, rsi, rdi, rsp, r8, r9, r10, r11, r12, r13, r14, r15.
// 
// GCC is giving us:
// exp_key      - rdi 
// iptr         - rsi
// iendptr      - iendptr
// optr         - rcx
// IV           - r8d
// TO BE ADDED // AAD          - r9d 
// TO BE ADDED // TAG          - r10d - the mac, called TAG by some of the tests. Will this be on the stack?
//
// callee save restore frees up everything for us but:
// We need a 32 bit counter, which we'll put in rax.
// As rsp is the stack pointer, and a frame pointer, rbp may be in use.
// Leaving us: rax, rbx, r9, r10, r11, r12, r13, r14, r15.

// As we'd like to be able to unroll up to 8 way and we need 1 32 bit tmp counter per
// GCTR unfolding, we need up to 8 32 bit temporary registers: 
//
// We need a 96 bit IV in memory, 128 bit, zeros for the last 32, pointed to by r10;
// Then each unrolling gets two xmm registers for an eight way unrolling.
// The temporary registers will be supplied by name to all but final routine.
//
// Thus we own 100% of the 64 and 128 bit registers. 

procedure {:timeLimitMultiplier 3} AES128GCTREncryptStdcall1(ghost g : GCMSpec)
    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    // We OWN the machine, note that rsp is stack in this model.
    modifies mem; efl; 
             rax; rbx; rcx; rdx; rbp; rsi; rdi; stack; r8; r9; r10; r11; r12; r13; r14; r15;
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;

    requires
      GCMSpecDynInit(g, exp_key_ptr, ivptr, mem);
      (iendptr - iptr) % (1 * 16) == 0;
      HasAtLeastFrames(stack, 1);

    requires/ensures
       ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
       ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
       WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
 CalleeSaveLinux();
 // Initialize CTR.
 // Y0 is 1, Y1 the first one E(K,Y1) xor'd with P1, no P0 in the spec.
 Mov32(rax,const(2));
 AES128GCTREncrypt1(g);
 CalleeRestoreLinux();
 EMMS(); // Intel says call this before a return if you are touching XMM.
}

procedure {:timeLimitMultiplier 3} AES128GCTRDecryptStdcall1(ghost g : GCMSpec)
    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= rax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    // We OWN the machine, note that rsp is stack in this model.
    modifies mem; efl; 
             rax; rbx; rcx; rdx; rbp; rsi; rdi; stack; r8; r9; r10; r11; r12; r13; r14; r15;
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;

    requires
      GCMSpecDynInit(g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, 0, mem);
      (iendptr - iptr) % (1 * 16) == 0;
      HasAtLeastFrames(stack, 1);

    requires/ensures
       ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
       ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
       WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
 CalleeSaveLinux();
 // Initialize CTR.
 // Y0 is 1, Y1 the first one E(K,Y1) xor'd with P1, no P0 in the spec.
 Mov32(rax,const(2));
 AES128GCTREncrypt1(g);
 CalleeRestoreLinux();
 EMMS(); // Intel says call this before a return if you are touching XMM.
 Mov32(rax, const(0)); // Send back success by default until GHASH is done.
}
*/
#verbatim
}
#endverbatim

