include "../../../arch/x64/decls.vad"
include "../../../arch/x64/decls64.vad"
include{:verbatim} "../../../arch/x64/print.s.dfy"
include{:verbatim} "../../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "../../loopunroll/regions128.dfy"
include "../../loopunroll/regions128wrappers.vad"
include{:verbatim} "gcm_helpers.i.dfy"
include{:verbatim} "../gcm3.s.dfy" 
include{:verbatim} "proof.dfy" 
// for the instructions
include{:verbatim} "../../../lib/util/words_and_bytes.i.dfy"
include{:verbatim} "../../../lib/util/operations.i.dfy"
include "aes.vad" 

#verbatim
module GCMProven {

import opened x64_def_s
import opened x64_vale_i
import opened x64_print_s
import opened dafny_wrappers_i
import opened x64_decls_i
import opened x64_decls64_i
import opened regions128wrappers
import opened GCMModule
import opened GCMHelpers
import opened proof
import opened words_and_bytes_i
import opened operations_i
import opened aes_vale

#endverbatim

// This lets us pass in constant small increments for the unrolling.
procedure {:refined} {:bridge} AddN32(inout operand dst : uint32, inline src : uint32)
    modifies efl;
    requires {:refined false} op32(this, @dst);
    requires 0 <= src < 0x1_0000_0000;
    requires 0 <= dst < 0x1_0000_0000;
    requires dst + src < 0x1_0000_0000;
    ensures  dst == BitwiseAdd32(old(dst), src);
    ensures  dst == old(dst) + src;
    ensures  dst < 0x1_0000_0000;
    ensures {:refined false} op32(this, @dst); // It's as if dst loses its opness.
{
   lemma_BitwiseAdd32();
   Add32(dst, src);
} 


procedure LoadArray128'(out operand dst:Quadword, operand src:uint64, inline i:int,
    inline taint:taint, ghost id:heaplet_id)
    reads mem;
    modifies efl;
    requires/ensures
        mem?[id];
        mem[id] is QuadwordHeaplet;
        mem[id].quads?[addr128(old(src), i)];
        mem[id].quads[addr128(old(src), i)].t == taint;
    ensures
        dst == mem[id].quads[addr128(old(src), i)].v;
{
    Load128'(dst, src, 16 * i, taint, id);
}



#verbatim
}
#endverbatim

