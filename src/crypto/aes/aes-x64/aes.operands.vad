include{:verbatim} "../aes_lemmas.i.dfy"
include{:verbatim} "../../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "../../../arch/x64/vale.i.dfy"
include "../../../arch/x64/decls.vad"
// TODO UNDO 
include{:verbatim} "../../../lib/util/words_and_bytes.i.dfy"
include{:verbatim} "../../../lib/util/operations.i.dfy"

#verbatim
module aesoperands {

import opened x64_vale_i
import opened dafny_wrappers_i
import opened x64_decls_i
import opened AESLemmasModule
// TODO UNDO 
import opened words_and_bytes_i
import opened operations_i

#endverbatim

procedure {:refined} {:bridge}   {:instruction Ins(MOVDQU(dst, MakeHeapOp(src, offset, taint))) } 
          Load128'(out operand dst:Quadword, operand src:uint64, inline offset:int, 
                  inline taint:taint, ghost id:heaplet_id)
    requires/ensures
        ValidSrcAddr(mem, id, src + offset, 128, taint);
    reads mem;
    modifies efl;
    ensures
        dst == mem[id].quads[src + offset].v;
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure {:timeLimitMultiplier 2}      AES128EncryptFirstStepOp(
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    inline taint:taint,
    ghost K_id:heaplet_id,
    inout operand xm0 : Quadword,
    inout operand xm2 : Quadword
    ) returns (
     ghost xm0_trace_out:QuadwordSeq
    )
    reads
        r8; mem;
    modifies efl; 
    requires/ensures
      SeqLength(key) == 4;
      SeqLength(w) == 44;
      KeyExpansionPredicate(key, AES_128, w);
      ValidSrcAddr(mem, K_id, r8, 128, taint);
      mem[K_id].quads[r8].v == Quadword(w[0], w[1], w[2], w[3]);
      @xm0 != @xm2;
    ensures
      SeqLength(xm0_trace_out) == 1;
      xm0_trace_out[0] == xm0;
      IsValidAES128EncryptionTracePrefix(key, w, old(xm0), xm0_trace_out);
{
    // ROUND 0 - XOR

    Load128'(xm2, r8, 0, taint, K_id);
    assert xm2 == Quadword(w[0], w[1], w[2], w[3]);

    Pxor(xm0, xm2);

    xm0_trace_out := seq(xm0);
    assert IsValidAES128EncryptionTracePrefix(key, w, old(xm0), xm0_trace_out);
}


procedure AES128EncryptLastStepOp(
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    ghost input:Quadword,
    ghost xm0_trace_in:QuadwordSeq,
    inline taint:taint,
    ghost K_id:heaplet_id,
    inout operand xm0 : Quadword,
    inout operand xm2 : Quadword
    ) returns (
    ghost xm0_trace_out:QuadwordSeq
    )
    reads
        r8; mem;
    modifies efl;
    requires
        SeqLength(key) == 4;
        SeqLength(w) == 44;
        ValidSrcAddr(mem, K_id, r8+16*10, 128, taint);
        mem[K_id].quads[r8+16*10].v == Quadword(w[40], w[41], w[42], w[43]);
        KeyExpansionPredicate(key, AES_128, w);
        SeqLength(xm0_trace_in) == 10;
        xm0_trace_in[9] == xm0;
        IsValidAES128EncryptionTracePrefix(key, w, input, xm0_trace_in);
        @xm0 != @xm2;
    ensures
        SeqLength(xm0_trace_out) == 11;
        xm0_trace_out[10] == xm0;
        IsValidAES128EncryptionTracePrefix(key, w, input, xm0_trace_out);
{
    ghost var old_xm0 := xm0;

    Load128'(xm2, r8, 16*10, taint, K_id);
    assert xm2 == seq_to_Quadword(SeqRange(w, 4*10, 4*10+4));
    AESNI_enc_last(xm0, xm2);

    ghost var new_xm0 := xm0;
    xm0_trace_out := SeqAppendElt(xm0_trace_in, new_xm0);

    lemma_ExtendingAES128EncryptionTracePrefix(key, w, input, 10, old_xm0, new_xm0, xm0_trace_in, xm0_trace_out);
}

procedure AES128EncryptMiddleStepOp(
    inline round:int,
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    ghost input:Quadword,
    ghost xm0_trace_in:QuadwordSeq,
    inline taint:taint,
    ghost K_id:heaplet_id,
    inout operand xm0 : Quadword,
    inout operand xm2 : Quadword
    ) returns (
    ghost xm0_trace_out:QuadwordSeq
    )
    reads
        r8; mem;
    modifies
       efl;
    requires
        SeqLength(xm0_trace_in) == round;
        1 <= round <= 9;
        xm0_trace_in[round-1] == xm0;
        IsValidAES128EncryptionTracePrefix(key, w, input, xm0_trace_in);
        SeqLength(key) == 4;
        SeqLength(w) == 44;
        ValidSrcAddr(mem, K_id, r8+16*round, 128, taint);
        mem[K_id].quads[r8+16*round].v == Quadword(w[4*round], w[4*round+1], w[4*round+2], w[4*round+3]);
        KeyExpansionPredicate(key, AES_128, w);
        @xm0 != @xm2;
    ensures
        SeqLength(xm0_trace_out) == round + 1;
        xm0_trace_out[round] == xm0;
        IsValidAES128EncryptionTracePrefix(key, w, input, xm0_trace_out);
{
    ghost var old_xm0 := xm0;

    Load128'(xm2, r8, 16*round, taint, K_id);
    assert xm2 == seq_to_Quadword(SeqRange(w, 4*round, 4*round+4));
    AESNI_enc(xm0, xm2);

    ghost var new_xm0 := xm0;
    xm0_trace_out := SeqAppendElt(xm0_trace_in, new_xm0);

    lemma_ExtendingAES128EncryptionTracePrefix(key, w, input, round, old_xm0, new_xm0, xm0_trace_in, xm0_trace_out);
}

procedure AES128EncryptOneBlockOp(
    ghost key:seq(uint32),
    ghost input:Quadword,
    ghost w:seq(uint32),
    inline taint:taint,
    inout operand xm0 : Quadword,
    inout operand xm2 : Quadword,
    ghost K_id:heaplet_id)
    reads
        mem; r8; 
    modifies
        efl;
    requires
        r8 % 16 == 0;
        SeqLength(key) == 4;
        xm0 == input;
        SeqLength(w) == 44;
        ValidSrcAddrs(mem, K_id, r8, 128, taint, 16*11);
        forall j :: 0 <= j <= 10 ==> mem[K_id].quads[r8 + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
        KeyExpansionPredicate(key, AES_128, w);
        @xm0 != @xm2;
    ensures
        (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
        (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
        xm0 == AES_Encrypt(key, input, AES_128);
{
    assert mem[K_id].quads[r8 + 16* 0].v == Quadword(w[4* 0], w[4* 0+1], w[4* 0+2], w[4* 0+3]);
    ghost var xm0_trace_step0:QuadwordSeq;
    xm0_trace_step0 := AES128EncryptFirstStepOp(key, w, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16* 1].v == Quadword(w[4* 1], w[4* 1+1], w[4* 1+2], w[4* 1+3]);
    ghost var xm0_trace_step1:QuadwordSeq;
    xm0_trace_step1 := AES128EncryptMiddleStepOp(1, key, w, input, xm0_trace_step0, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16* 2].v == Quadword(w[4* 2], w[4* 2+1], w[4* 2+2], w[4* 2+3]);
    ghost var xm0_trace_step2:QuadwordSeq;
    xm0_trace_step2 := AES128EncryptMiddleStepOp(2, key, w, input, xm0_trace_step1, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16* 3].v == Quadword(w[4* 3], w[4* 3+1], w[4* 3+2], w[4* 3+3]);
    ghost var xm0_trace_step3:QuadwordSeq;
    xm0_trace_step3 := AES128EncryptMiddleStepOp(3, key, w, input, xm0_trace_step2, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16* 4].v == Quadword(w[4* 4], w[4* 4+1], w[4* 4+2], w[4* 4+3]);
    ghost var xm0_trace_step4:QuadwordSeq;
    xm0_trace_step4 := AES128EncryptMiddleStepOp(4, key, w, input, xm0_trace_step3, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16* 5].v == Quadword(w[4* 5], w[4* 5+1], w[4* 5+2], w[4* 5+3]);
    ghost var xm0_trace_step5:QuadwordSeq;
    xm0_trace_step5 := AES128EncryptMiddleStepOp(5, key, w, input, xm0_trace_step4, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16* 6].v == Quadword(w[4* 6], w[4* 6+1], w[4* 6+2], w[4* 6+3]);
    ghost var xm0_trace_step6:QuadwordSeq;
    xm0_trace_step6 := AES128EncryptMiddleStepOp(6, key, w, input, xm0_trace_step5, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16* 7].v == Quadword(w[4* 7], w[4* 7+1], w[4* 7+2], w[4* 7+3]);
    ghost var xm0_trace_step7:QuadwordSeq;
    xm0_trace_step7 := AES128EncryptMiddleStepOp(7, key, w, input, xm0_trace_step6, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16* 8].v == Quadword(w[4* 8], w[4* 8+1], w[4* 8+2], w[4* 8+3]);
    ghost var xm0_trace_step8:QuadwordSeq;
    xm0_trace_step8 := AES128EncryptMiddleStepOp(8, key, w, input, xm0_trace_step7, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16* 9].v == Quadword(w[4* 9], w[4* 9+1], w[4* 9+2], w[4* 9+3]);
    ghost var xm0_trace_step9:QuadwordSeq;
    xm0_trace_step9 := AES128EncryptMiddleStepOp(9, key, w, input, xm0_trace_step8, taint, K_id, xm0, xm2);

    assert mem[K_id].quads[r8 + 16*10].v == Quadword(w[4*10], w[4*10+1], w[4*10+2], w[4*10+3]);
    ghost var xm0_trace_step10:QuadwordSeq;
    xm0_trace_step10 := AES128EncryptLastStepOp(key, w, input, xm0_trace_step9, taint, K_id, xm0, xm2);

    lemma_AES128Encrypt(key, input, w, xm0, xm0_trace_step10);
    assert (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
    assert (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
    assert xm0 == AES_Encrypt(key, input, AES_128);

    // Clear secrets out of registers
    Pxor(xm2, xm2);
}


#verbatim
}
#endverbatim
