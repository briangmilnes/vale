// x64 version.
//// See testctr.c for calling conventions.

include "../../../arch/x64/decls.vad"
include "../../../arch/x64/decls64.vad"
include{:verbatim} "../../../arch/x64/print.s.dfy"
include{:verbatim} "../../../lib/util/dafny_wrappers.i.dfy"
include "aes.vad"
include{:verbatim} "../ctr_helpers.i.dfy"
include{:verbatim} "../ctr.s.dfy" 
include{:verbatim} "../ctr_clean.s.dfy" 

#verbatim
module CTR {

import opened x64_def_s
import opened x64_vale_i
import opened x64_print_s
import opened dafny_wrappers_i
import opened x64_decls_i
import opened x64_decls64_i
import opened aes_vale
import opened CTRModule
import opened CTR_Helpers
import opened CTRModuleClean

#endverbatim

// There seem to be three ways to do this job:
// (1) Pass two pointers to 128 bit counters, one input and one output.
// (2) Pass one point to a 128 bit counter and update it in place.
// (3) Pass one or two 128 bit registers.
// We'll try (1) first as it's the most complicated and I learn the
// most. If we want to pass arguments in registers, we'd just do it
// in Vale.

// And we have two calling conventions, 
//
// Starting with https://en.wikipedia.org/wiki/X86_calling_conventions.
// So this is cdecl style on x64.
// We'll come back to making it windows safe.

// First the AES encryption tests. 

// Calling convention so we can call this from C for test.
//  We should get up to four arguments on the stack in
// that order with x64 calling conventions.
//  rdi == expanded_key pointer
//  esi == counter pointer 
//  rdx == input pointer
//  rcx == output pointer
// Actually passing args in rdi, esi, rdx, rcx. 
// but gcc gives us esi but its zero extended in rsi.

procedure {:refined} {:timeLimitMultiplier 3} CTREncryptOneBlockStdCall(
   ghost key:seq(uint32), 
   ghost w:seq(uint32),
   ghost ctr_heap_id: heaplet_id,
   ghost key_heap_id: heaplet_id,
   ghost input:Quadword,
   ghost in_heap_id : heaplet_id,
   ghost out_heap_id: heaplet_id,
   ghost alg:Algorithm
   ) returns (
    ghost output:Quadword
  )
    reads
      rcx; rsi;

    modifies
        mem; efl; xmm0; xmm1; r8; xmm2; rdi; rdx; 

    requires 
     let key_ptr     := rdi;
     let ctr_ptr     := rsi; // moved into xmm0 as it's the input 
     let in_ptr      := rdx; // moved into xmm1 so it can be xord with xmm0.
     let out_ptr     := rcx; // has xmm0 stored into it.
     
     // AES requirements
     SeqLength(w) == 44;
     SeqLength(key) == 4;
     KeyExpansionPredicate(key, AES_128, w);
     ValidSrcAddrs(mem, key_heap_id, rdi, 128, Secret, 16*11);
     forall j :: 0 <= j <= 10 ==>
         mem[key_heap_id].quads[rdi + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);

     key_ptr % 16 == 0;
     ValidSrcAddr(mem, ctr_heap_id, ctr_ptr, 128, Public);
     ValidSrcAddr(mem, in_heap_id,   in_ptr, 128, Secret);
     ValidSrcAddr(mem, out_heap_id, out_ptr, 128, Public);

     out_heap_id != key_heap_id;
     out_heap_id != ctr_heap_id;
     out_heap_id != in_heap_id;

  ensures
     let out_ptr     := rcx; // has xmm0 stored into it.
     ValidSrcAddr(mem, out_heap_id, out_ptr, 128, Public);

     // The memory is written only on the output heap.
     mem == old(mem)[out_heap_id := mem[out_heap_id]];

    // The rest of the output heap is unchanged. 
    // Warning about mem64 can only be applied to Heaplet64 objects.
    // Bryan question.
    // The rest of the output heap is unchanged.
    //    forall a :: (a < out_ptr || a >= out_ptr + 128) && 
    //      old(mem)[out_heap_id].mem64?[a] ==>  mem[out_heap_id].mem64?[a] && 
    //      mem[out_heap_id].mem64[a] == old(mem)[out_heap_id].mem64[a];

    // No way this is right.
    // InputMatchesMemory(input,   mem[in_heap_id], ?);
    // InputMatchesMemory(counter, mem[ctr_heap_id], ?);
    //CTR_Encrypt_One_Block_Final(key,
    //                            input,
    //                            counter,
    //                          alg,
    //                            mem,
    //                           output_heap_id,
    //                           rcx,
    //                            output);
{
     Load128(xmm0, rsi, 0, Public, ctr_heap_id);                 // Load the counter into xmm0.
     Mov64(r8, rdi);                                             // key in r8, 16 byte aligned.
     AES128EncryptOneBlock(key, xmm0, w, Secret, key_heap_id);   // Encrypt the counter back into xmm0.
     Load128(xmm1, rdx,  0, Secret, in_heap_id);                 // Load the block of plaintext.
     Pxor(xmm0, xmm1);                                           // Xor the encrypted counter with the plaintext.
     Store128(rcx, xmm0, 0, Public, out_heap_id);                // Store the cyphertext.

  // Clean up state.
  Xor64(rdx,rdx);
  Xor64(rdi,rdi);
  Pxor(xmm0, xmm0);
  Pxor(xmm1, xmm1);
}

// Decryption uses the same routine as we just xor again but the taints are different.

/// Second, do a 128 bit input/output but don't keep a 128 bit value in memory.

procedure {:refined} CTR128Increment64StdCall(
   ghost  in_ctr_heap_id: heaplet_id,
   ghost  out_ctr_heap_id: heaplet_id
)
// Does this need a ghost output?

   modifies
        mem; efl; rdi; rsi; rdx;

   requires
     let in_ctr_ptr  := rdi;
     let out_ctr_ptr := rsi;
     ValidSrcAddr(mem,  in_ctr_heap_id, in_ctr_ptr, 64, Public);
     ValidSrcAddr(mem,  in_ctr_heap_id, in_ctr_ptr + 8, 64, Public);
     ValidDstAddr(mem, out_ctr_heap_id, out_ctr_ptr, 64);
     ValidDstAddr(mem, out_ctr_heap_id, out_ctr_ptr + 8, 64);
     in_ctr_ptr % 8 == 0;
     out_ctr_ptr % 8 == 0;
     in_ctr_heap_id != out_ctr_heap_id;

   ensures
     let in_ctr_ptr  := old(rdi);
     let out_ctr_ptr := old(rsi);

     // What properties do I want to prove?

     // I have not touched the stack as it is not in the modifies.
     // I have not changed the input. 
     // Implied by not changing the heaplet.
     //ValidSrcAddr(mem,  in_ctr_heap_id, in_ctr_ptr, 64, Public);
     //ValidSrcAddr(mem,  in_ctr_heap_id, in_ctr_ptr + 8, 64, Public);
     // I have valid output addresses, Src => Dst.
//     ValidSrcAddr(mem, out_ctr_heap_id, out_ctr_ptr, 64, Public);
//     ValidSrcAddr(mem, out_ctr_heap_id, out_ctr_ptr + 8, 64, Public);

    // 2 64 byte stretches are the only things changed.
//    Mem64ChangedOnlyIn(out_ctr_ptr, 2, out_ctr_heap_id, mem, old(mem));

     // High half of the output is the low half of the input.
//    mem[out_ctr_heap_id].mem64[out_ctr_ptr+8].t == old(mem)[in_ctr_heap_id].mem64[in_ctr_ptr+8].t;

    // High half of the output is the high half of the input + 1 mod 2^64.
//    mem[out_ctr_heap_id].mem64[out_ctr_ptr].v ==
//    BitwiseAdd64(old(mem)[in_ctr_heap_id].mem64[in_ctr_ptr].v, 1);

{
    ghost var in_ctr_ptr  := rdi;
    ghost var out_ctr_ptr := rsi;
 
    // Grab the counter low bits, add 1, store it.
    Load64 (rdx, rdi, 0, Public, in_ctr_heap_id);
    //Add64(rdx, 1); // Why will this not work?
    incr64 (rdx); 
    Store64(rsi, rdx, 0, Public, out_ctr_heap_id);

    // Grab the counter high bits, the IV, and store it.
    Load64 (rdx, rdi, 8, Public, in_ctr_heap_id);
    Store64(rsi, rdx, 8, Public, out_ctr_heap_id);

    // Clean up state.
    Xor64(rdi,rdi);
    Xor64(rsi,rsi);
    Xor64(rdx,rdx);
 }

procedure{:refined} {:bridge} {:instruction Ins(MOVQ64XMM(dst, src))} 
    MovLow64To64(out operand dst:uint64, operand src:Quadword)
  ensures
  dst == old(lowerUpper64(src.lo, src.mid_lo));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
    ghost if (!this.ok)
    {
        this := this.(regs := this.regs[@dst.r := 0]);
    }
}

procedure{:refined}  {:bridge} {:instruction Ins(MOVQXMM64(dst, src))} 
    MovLow64To128(inout operand dst: Quadword, operand src:uint64)
  ensures
    dst == old(Quadword(lower64(src), upper64(src), dst.mid_hi, dst.hi));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

// movhlps  - high 64 to low 64 bit move
procedure{:refined} {:bridge} {:instruction Ins(MOVHLPS(dst, src))} 
    MOVHLPS(inout operand dst:Quadword, operand src:Quadword)
  ensures
    dst == old(Quadword(src.mid_hi, src.hi, dst.mid_hi, dst.hi));
{
   reveal evalCodeOpaque;
   reveal x86_ValidState;
   this := MaybeUpdateOk(old(this), this);
   this := this.(heaplets := old(this).heaplets);
}

//// movlhps  - low 64 to high 64 bit move
procedure{:refined} {:bridge} {:instruction Ins(MOVLHPS(dst, src))} 
    MOVLHPS(inout operand dst:Quadword, operand src:Quadword)
  ensures
    dst == old(Quadword(dst.lo, dst.mid_lo, src.lo, src.mid_lo));
{
   reveal evalCodeOpaque;
   reveal x86_ValidState;
   this := MaybeUpdateOk(old(this), this);
   this := this.(heaplets := old(this).heaplets);
}

// The register version of this with a 128 bit register kept. 
//procedure {:refined} CTR128Increment128Reg(
//   ghost  counter         : Quadword,
//   inout  operand xmm     : Quadword,
//   inout  operand temp64  : uint64,
//   inout  operand temp128 : Quadword
//)
//returns (
//  ghost incrcounter : Quadword
//)
//   requires
//     CtrInReg(counter, xmm);
//     xmm != temp128;
//
//   modifies
//        efl;
//
//   ensures
////        IncrCtrInReg(counter, incrcounter, xmm); // BUG! Bryan pls comment.
//   // xmm.hi == old(xmm).hi;
//   //incrcounter == xmm;
//{
////no      MovLow64To64(temp64, xmm);  // Grab counter half.
////no      MOVHLPS(temp128, xmm);      // Save IV half in temp128.
////        incr64(temp64);
////      MovLow64To128(xmm, temp64); // But zeros top bytes.
////      MOVLHPS(xmm, temp128);      // Put back the IV.
//        Xor64(temp64, temp64);
//        Pxor(temp128, temp128); // uncomment and fail in the precondition with an ok.
//        incrcounter := xmm;
//}

// This one should work but may be part of the problem.
// The 128 bit standard call that sets up the 128 bit register of this.
//procedure {:refined} CTR128Increment128StdCall(
//   ghost  counter : Quadword, 
//   ghost  in_ctr_heap_id: heaplet_id,
//   ghost  out_ctr_heap_id: heaplet_id
//)
//returns (
//  ghost incrcounter : Quadword
//)
//
//   modifies
//        mem; efl; rdi; rsi; rdx; xmm0; xmm1;
//
//   requires
//     let in_ctr_ptr  := rdi;
//     let out_ctr_ptr := rsi;
//   
//   //  I have a counter in memory.
//   CtrInMem(counter, rdi, in_ctr_heap_id, mem);
//   // And a place two write out when incremented.
//   ValidDstAddr(mem, out_ctr_heap_id, out_ctr_ptr, 128);
//
//   in_ctr_heap_id != out_ctr_heap_id;
//
//   ensures
////     let in_ctr_ptr  := old(rdi);
////     let out_ctr_ptr := old(rsi);
////     // I am only changing 1 quad word.
////     Mem128ChangedOnlyIn(out_ctr_ptr, 1, out_ctr_heap_id, mem, old(mem));
////     // And I placed the incremented counter in it.
////     CtrInMem(incrcounter, rsi, out_ctr_heap_id, mem);
//{
//      Load128(xmm0, rdi, 0, Public, in_ctr_heap_id);
//      assert counter == xmm0;
//      incrcounter := CTR128Increment128Reg(counter, xmm0, rdx, xmm1);
//      Store128(rsi, xmm0, 0, Public, out_ctr_heap_id);
//}


// Dummy version.
//procedure {:refined} CTR128Increment128StdCall(
//   ghost  counter : Quadword, 
//   ghost  in_ctr_heap_id: heaplet_id,
//   ghost  out_ctr_heap_id: heaplet_id
//)
//returns (
//  ghost incrcounter : Quadword
//)
//{
//}
  

// Try a single routine version!
// The 128 bit standard call that sets up the 128 bit register of this.
procedure {:refined} CTR128Increment128StdCall(
   ghost  counter : Quadword, 
   ghost  in_ctr_heap_id: heaplet_id,
   ghost  out_ctr_heap_id: heaplet_id
)
returns (
  ghost incrcounter : Quadword
)

   modifies
        mem; efl; rdi; rsi; rdx; xmm0; xmm1;

   requires
     let in_ctr_ptr  := rdi;
     let out_ctr_ptr := rsi;
   
   //  I have a counter in memory.
   CtrInMem(counter, rdi, in_ctr_heap_id, mem);
   // And a place two write out when incremented.
   ValidDstAddr(mem, out_ctr_heap_id, out_ctr_ptr, 128);

   in_ctr_heap_id != out_ctr_heap_id;

   ensures
//     let in_ctr_ptr  := old(rdi);
//     let out_ctr_ptr := old(rsi);
//     // I am only changing 1 quad word.
//     Mem128ChangedOnlyIn(out_ctr_ptr, 1, out_ctr_heap_id, mem, old(mem));
//     // And I placed the incremented counter in it.
//     CtrInMem(incrcounter, rsi, out_ctr_heap_id, mem);
{
      Load128(xmm0, rdi, 0, Public, in_ctr_heap_id);
//      Perhaps this sub call is the total problem? yes it appears to be.
//      incrcounter := CTR128Increment128Reg(counter, xmm0, rdx, xmm1);
      assert counter == xmm0;
      MovLow64To64(rdx, xmm0);  // Grab counter half.
      MOVHLPS(xmm1, xmm0);      // Save IV half in temp128.
      incr64(rdx);
      MovLow64To128(xmm0, rdx); // But zeros top bytes.
      MOVLHPS(xmm0, xmm1);      // Put back the IV.
      Xor64(rdx, rdx);          // Clean up.
      Pxor(xmm1,xmm1);
      incrcounter := xmm0;
      Store128(rsi, xmm0, 0, Public, out_ctr_heap_id); // Put it back.
}

#verbatim
} // end module CTR
#endverbatim


