include "../../../arch/x64/decls.vad"
include "../../../arch/x64/decls64.vad"
include{:verbatim} "../../../arch/x64/print.s.dfy"
include{:verbatim} "../../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "../../loopunroll/regions128.dfy"
include "../../loopunroll/regions128wrappers.vad"
include "../../loopunroll/regions64wrappers.vad" // Just for debugging
include "aes.vad" 
include{:verbatim} "gcm_helpers.i.dfy"
include{:verbatim} "../gcm3.s.dfy" 
include "gcm.proven.vad"
// for the instructions
include{:verbatim} "../../../lib/util/words_and_bytes.i.dfy"
include{:verbatim} "../../../lib/util/operations.i.dfy"
include "../../loopunroll/calleesave.vad"

#verbatim
module GCM {

import opened x64_def_s
import opened x64_vale_i
import opened x64_print_s
import opened dafny_wrappers_i
import opened x64_decls_i
import opened x64_decls64_i
import opened regions128wrappers
import opened regions64wrappers
import opened GCMModule
import opened GCMHelpers
import opened GCMProven
import opened proof
import opened words_and_bytes_i
import opened operations_i
import opened aes_vale
import opened CalleeSaveRestore

#endverbatim


procedure BUG(inout operand tmp    : Quadword,
              inout operand addtmp : uint32)
   modifies efl;
   requires op32(this, @addtmp);
   ensures  0 <= addtmp < 0x1_0000_0000;
   ensures  op32(this, @addtmp);
{
   MOVD_xmm_rmm32(tmp, addtmp);
}  

procedure CallBUG()
   modifies efl; eax; xmm0;
   requires reg32(this, X86Eax);
   ensures reg32(this, X86Eax);
{
  BUG(xmm0, eax);
  assert 0 <= eax < 0x1_0000_0000;
} 

/*
// We can't use operands into here due to the inability to timely prove their inequalty with registers.
procedure {:recursive} {:timeLimitMultiplier 4} AESGCTRUnrolled
         (ghost g: GCMSpec,
          ghost off : uint32, 
          inline step : uint32)

    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= eax;
    lets tmp32_1 @=ebx; tmp32_2 @=r9d; tmp32_3 @=r10d; tmp32_4 @=r11d; tmp32_5 @=r12d; tmp32_6 @=r13d; tmp32_7 @=r14d; tmp32_8 @=r15d;

    reads    exp_key_ptr; iptr; iendptr; optr; ivptr; ctr;
    modifies mem; efl; 
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
             tmp32_1; tmp32_2;  tmp32_3;  tmp32_4;  tmp32_5;  tmp32_6;  tmp32_7;  tmp32_8; 

    requires/ensures
      reg32(this, X86Eax); reg32(this, X86Ebx); reg32(this, X86R9); reg32(this, X86R10); reg32(this, X86R11); 
      reg32(this, X86R12); reg32(this, X86R13); reg32(this, X86R14); reg32(this, X86R15);

    requires
       off + step < (iendptr - iptr) / 16;
       0 <= step < 8; 
       0 <= ctr + step < 0x1_0000_0000;

    requires/ensures 
        GCMSpecDyn(g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, mem);
        ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, g.isize, Secret, iptr, off, step);
        ValidDstRegPtrs128(mem, g.oheap, g.oaddr, g.isize,         optr, off, step);
        WritesReg128(mem, g.oheap, g.oaddr, g.isize, off,         Public, AESGCTRSeq(mem, g, g.isize));

    ensures
         OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
         OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
         // This means I wrote off + step + 1 of the output in total.
//         WritesReg128(mem, g.oheap, g.oaddr, g.isize, off + step + 1, Public, AESGCTRSeq(mem, g, g.isize));
{
  inline if (step == 7) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_8, xmm13, xmm14);
  } else if (step == 6) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_7, xmm12, xmm13);
  } else if (step == 5) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_6, xmm10, xmm11);
  }  else if (step == 4) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_5, xmm8, xmm9);
  } else if (step == 3) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_4, xmm6, xmm7); 
  } else if (step == 2) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_3, xmm4, xmm5);
  } else if (step == 1) {
       AESGCTRUnrolled(g, off, step - 1);
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_1, xmm2, xmm3);
   } else  if (step == 0) {                                    
       AESGCTR1       (g, exp_key_ptr, iptr, iendptr, optr, ivptr, ctr, off, step, tmp32_2, xmm0, xmm1);
   }
}  
*/


/*
procedure {:timeLimitMultiplier 3} AESGCTRLoopOverUnrolled
          (ghost g : GCMSpec,
           inline n : uint8nonzero)
    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= eax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    reads    exp_key_ptr; ivptr; 
    modifies iptr; iendptr; optr; ctr;
    modifies mem; efl; 
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
             tmp32_1; tmp32_2;  tmp32_3;  tmp32_4;  tmp32_5;  tmp32_6;  tmp32_7;  tmp32_8; 

    requires
      GCMSpecDynInit(g, exp_key_ptr, iptr, iendptr, optr, ivptr, mem);
      0 < n <= 8;
      (iendptr - iptr) % (n * 16) == 0;

    requires/ensures
        GCMSpecDyn(g, exp_key_ptr, iptr, iendptr, optr, ivptr, mem);
        ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
        ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
       WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
    ghost var index   : int := 0;
    lemma_regdiff_loop_ge_uint128'(iendptr, iptr, n);
    while (iptr < iendptr)
        invariant
            ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
            ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

            0 <= index <= g.isize;
            index == g.isize - (iendptr - iptr) / 16;
            iptr  == g.iaddr + 16 * index;
            optr  == g.oaddr + 16 * index;
            (iptr < iendptr) ==> g.isize >= 1; // Interesting that it can't prove this on entry wo ==>.
            (iendptr - iptr) % (n * 16) == 0;
            (iptr < iendptr) ==> (iendptr - iptr) >= (n * 16); // lemma above
            (iendptr - iptr) > 0 ==> index + n - 1 < (iendptr - iptr) / 16;

            (iptr < iendptr) ==> 0 <= index + n - 1 < g.isize;
            (index < g.isize) ==> 
               ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, g.isize, Secret, iptr, index, n - 1);
            (index < g.isize) ==> 
               ValidDstRegPtrs128(mem, g.oheap, g.oaddr, g.isize,         optr, index, n - 1);

            OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
            OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
            WritesReg128(mem, g.oheap, g.oaddr, g.isize, index, Public, 
                                 AESGCTRSeq(old(mem), g, g.isize));
          decreases (iendptr - iptr);
    {
        AESGCTRUnrolled(g, index, n - 1);
        ghost var iptr' := iptr;
        Add(iptr, const(n * 16));
        Add(optr, const(n * 16));
        Add(ctr, const(n));
        index := index + n;
    }
  assert g.isize == index; 
  assert iendptr - iptr == 0;
}

// Encrypt, gctr only with the stack saved and the arguments in the expected place.
procedure AES128GCTREncrypt1(ghost g : GCMSpec)
    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= eax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    reads    exp_key_ptr; ivptr; 
    modifies iptr; iendptr; optr; ctr;
    modifies mem; efl; 
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
             tmp32_1; tmp32_2;  tmp32_3;  tmp32_4;  tmp32_5;  tmp32_6;  tmp32_7;  tmp32_8; 

    requires
      GCMSpecDynInit(g, exp_key_ptr, iptr, iendptr, optr, ivptr, mem);
      (iendptr - iptr) % (1 * 16) == 0;

    requires/ensures
        GCMSpecDyn(g, exp_key_ptr, iptr, iendptr, optr, ivptr, mem);
        ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
        ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
       WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
  AESGCTRLoopOverUnrolled(g,1);
} 

// Setup just the GCM CTR mode from a standard call.
//
// All MM registers are: rax, rbx, rcx, rdx, rbp, rsi, rdi, rsp, r8, r9, r10, r11, r12, r13, r14, r15.
// 
// GCC is giving us:
// exp_key      - rdi 
// iptr         - rsi
// iendptr      - rdx
// optr         - rcx
// IV           - r8d
// TO BE ADDED // AAD          - r9d 
// TO BE ADDED // TAG          - r10d - the mac, called TAG by some of the tests. Will this be on the stack?
//
// callee save restore frees up everything for us but:
// We need a 32 bit counter, which we'll put in rax.
// As rsp is the stack pointer, and a frame pointer, rbp may be in use.
// Leaving us: rax, rbx, r9, r10, r11, r12, r13, r14, r15.

// As we'd like to be able to unroll up to 8 way and we need 1 32 bit tmp counter per
// GCTR unfolding, we need up to 8 32 bit temporary registers: 
//
// We need a 96 bit IV in memory, 128 bit, zeros for the last 32, pointed to by r10;
// Then each unrolling gets two xmm registers for an eight way unrolling.
// The temporary registers will be supplied by name to all but final routine.
//
// Thus we own 100% of the 64 and 128 bit registers. 

procedure {:timeLimitMultiplier 3} AES128GCTREncryptStdcall1(ghost g : GCMSpec)
    lets exp_key_ptr @= rdi; iptr @= rsi; iendptr @= rdx; optr @= rcx; ivptr @= r8; ctr @= eax;
    lets tmp32_1 @=rbx; tmp32_2 @=r9; tmp32_3 @=r10; tmp32_4 @=r11; tmp32_5 @=r12; tmp32_6 @=r13; tmp32_7 @=r14; tmp32_8 @=r15;

    // We OWN the machine, note that rsp is stack in this model.
    modifies mem; efl; 
             rax; rbx; rcx; rdx; rbp; rsi; rdi; stack; r8; r9; r10; r11; r12; r13; r14; r15;
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;

    requires
      GCMSpecDynInit(g, exp_key_ptr, iptr, iendptr, optr, ivptr, mem);
      (iendptr - iptr) % (1 * 16) == 0;
      HasAtLeastFrames(stack, 1);

    requires/ensures
        GCMSpecDyn(g, exp_key_ptr, iptr, iendptr, optr, ivptr, mem);
        ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
        ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
       WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g, g.isize));
{
 CalleeSaveLinux();
 // Initialize CTR.
 Mov32(rax,const(1)); // It starts out at 1.
 AES128GCTREncrypt1(g);
 CalleeRestoreLinux();
 EMMS(); // Intel says call this before a return if you are touching XMM.
}
*/

// Dummies for testing the test code.
//procedure {:timeLimitMultiplier 3} AES128GCTREncryptStdcall(ghost g : GCMSpec) {}  
//procedure {:timeLimitMultiplier 3} AES128GCTRDecryptStdcall(ghost g : GCMSpec) {} 

#verbatim
} // end module CGM
#endverbatim
