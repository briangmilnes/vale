include "../../../arch/x64/decls.vad"
include "../../../arch/x64/decls64.vad"
include{:verbatim} "../../../arch/x64/print.s.dfy"
include{:verbatim} "../../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "../../loopunroll/regions128.dfy"
include "../../loopunroll/regions128wrappers.vad"
include{:verbatim}   "../../loopunroll/copy128.dfy"
include "aes.vad" 
include{:verbatim} "gcm_helpers.i.dfy"
include{:verbatim} "../gcm3.s.dfy" 
include "gcm.proven.vad"
// for the instructions
include{:verbatim} "../../../lib/util/words_and_bytes.i.dfy"
include{:verbatim} "../../../lib/util/operations.i.dfy"

#verbatim
module GCM {

import opened x64_def_s
import opened x64_vale_i
import opened x64_print_s
import opened dafny_wrappers_i
import opened x64_decls_i
import opened x64_decls64_i
//import opened aes_vale
import opened regions128wrappers
import opened copy128
import opened GCMModule
import opened GCMHelpers
import opened proof
import opened words_and_bytes_i
import opened operations_i
import opened aes_vale

#endverbatim

/*
procedure {:refined} {:bridge}
{:instruction Ins(Pxor(dst, src))} Pxor'(inout operand dst:Quadword, operand src:Quadword)
  modifies efl;
  ensures
    dst == old(QuadwordXor(dst, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}
*/

/*
procedure {:refined} {:bridge}   {:instruction Ins(MOVDQU(dst, MakeHeapOp(src, offset, taint))) } 
          Load128'(out operand dst:Quadword, operand src:uint64, inline offset:int, 
                  inline taint:taint, ghost id:heaplet_id)
    requires/ensures
        ValidSrcAddr(mem, id, src + offset, 128, taint);
    reads mem;
    modifies efl;
    ensures
        dst == mem[id].quads[src + offset].v;
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure BUG(operand ipter  : uint64,
          ghost    iheap  : heaplet_id,
          ghost    iaddr  : uint64, 
          ghost    isize  : uint64,
          ghost    off    : nat,
          inline   add    : nat, 
          inout operand tmpctr : Quadword, 
          inout operand tmp : Quadword)
  requires{:refined false}
      @ipter  is OReg;

  requires
        ValidSrcRegPtrs128(mem, iheap, iaddr, isize, Secret, ipter, off, add);

  modifies xmm0; efl; mem;
{
     Load128'(tmp,    ipter, add, Secret, iheap);         // Load the plaintext.
     LoadArray128 (tmp,    ipter, add, Secret, iheap);         // Load the plaintext.
     Pxor(tmp,tmp);
}    
*/

// Test to move to a ghost G.
// Key for AES is in r8, 16 byte aligned.
procedure {:bridge} {:timeLimitMultiplier 3} AESGCTR128
         (ghost g: G,
          operand ipter  : uint64,
          operand optr  : uint64,
          ghost    off    : nat,
          inline   add    : nat, 
          operand       icb : Quadword,    // The ICB in the left high 92 bits.
          operand       ctr : uint32,      // The counter that we read from and add a fixed offset.
          inout operand addtmp : uint32,   // Where we add the ctr.
          inout operand tmpctr : Quadword, // Where we build the ICB||CTR.
          inout operand tmp    : Quadword  // A tmp for AES plus where we put the plain text.
)
    reads r8;
    modifies mem; efl; xmm0; rsi;
    requires DistinctORegs3(@ipter, @optr, @tmp);

    requires/ensures 
        off + add < g.isize;
        ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, g.isize, Public, ipter, off, add);
        ValidDstRegPtrs128(mem, g.oheap, g.oaddr, g.isize,        optr, off, add);
//        WritesReg128(mem, g.oheap, g.oaddr, g.isize, off + add, Public,
//                   Copy128Seq(old(mem), g.iheap, g.iaddr, g.isize, g.isize));

    ensures 
         OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
         OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
//         WritesReg128(mem, g.oheap, g.oaddr, g.isize, off + add + 1, Public,
//                   Copy128Seq(old(mem), g.iheap, g.iaddr, g.isize, g.isize));
{

   Mov(addtmp, ctr);                                 // Get the ctr.
   AddN32(addtmp, add);                              // Add our offset to it: 0, 1, ...; const folding elim here?
   Mov32ToLow128(tmp, addtmp);                       // Put low 32 bits into an xmm tmp.
   Mov128'(tmpctr, icb);                              // Get the IV+32 bit counter.
   Pxor(tmpctr, tmp);                                // ICB (96 bits) || ctr for this offset.
   AES128EncryptOneBlockOp(g.key, tmpctr, g.exp_key, Secret, tmpctr, tmp, g.key_heap); // Encrypt the counter back into tmpctr.
   LoadArray128(tmp, ipter, add, Secret, g.iheap);   // Load the plaintext into tmp.
   Pxor(tmp, tmpctr);                                // Xor the encrypted counter with the plaintext.
   StoreArray128(optr,   tmp, add, Public, g.oheap); // Write it back to the output.
}     

/*

// This primed version works but the final loop takes 22s to prove due to the complete
// graph of inequalities of registers.
procedure {:recursive} {:timeLimitMultiplier 1} AESGCTRUnrolled
         (ghost g: G,
          operand iptr : uint64, operand optr : uint64, 
          inout operand tmp1 : Quadword, inout operand tmp2 : Quadword, inout operand tmp3 : Quadword, inout operand tmp4 : Quadword, 
          ghost off : nat, inline step : nat)
                               
    modifies mem; efl; 

    requires
       1 <= g.isize;
       // Must have at least on address to write.
       off + step < g.isize; 
       0 <= step < 4;
       g.iaddr != g.oaddr;
       DistinctORegs6(@iptr, @optr, @tmp1, @tmp2, @tmp3, @tmp4);

    requires/ensures 
           g.iheap != g.oheap; 
           ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, g.isize, Secret, iptr, off, step);
           ValidDstRegPtrs128(mem, g.oheap, g.oaddr, g.isize,        optr, off, step);
           WritesReg128(mem, g.oheap, g.oaddr, g.isize, off, Public,
                 Copy128Seq(old(mem), g.iheap, g.iaddr, g.isize, g.isize));

    ensures
         OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
         OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
         // This means I wrote off + step + 1 of the output in total.
         WritesReg128(mem, g.oheap, g.oaddr, g.isize, off + step + 1, Public
                   Copy128Seq(old(mem), g.iheap, g.iaddr, g.isize, g.isize));
{
  inline if (step == 3) {
       AESGCTRUnrolled(g, iptr, optr, tmp1, tmp2, tmp3, tmp4, off, step - 1);
       AESGCTR(g, taint, iptr, optr, off, step, tmp1);
  } else if (step == 2) {
       AESGCTRUnrolled(g, iptr, optr, tmp1, tmp2, tmp3, tmp4, off, step - 1);
       AESGCTR(g, taint, iptr, optr, off, step, tmp2);
  } else if (step == 1) {
       AESGCTRUnrolled(g, iptr, optr, tmp1, tmp2, tmp3, tmp4, off, step - 1);
       AESGCTR(g, taint, iptr, optr, off, step, tmp3);
   } else if (step == 0) {                                    
       AESGCTR(g, taint, iptr, optr, off, step, tmp4);
   }
}
*/

/*

procedure {:timeLimitMultiplier 3} AESGCTRLoopOverUnrolled
          (ghost g : G,
           inline taint:taint, 
           inout operand iptr : uint64, operand iendptr : uint64, inout operand optr : uint64,
           inout operand tmp1 : Quadword, inout operand tmp2 : Quadword, inout operand tmp3 : Quadword, inout operand tmp4 : Quadword, 
           inline n : uint8)
    let items :=  (old(iendptr) - old(iptr)) / 16;

    modifies mem; efl; 
    // But will this call? May have to split out the iptr/iendptr/optr/items.
    requires
      g.iaddr == old(iptr);
      g.oaddr == old(optr);
      g.isize  == items;
      g.iaddr != g.oaddr; // Hmm, is this necessary?
    requires
        0 < n <= 4;
        iendptr >= iptr; 
        (iendptr - iptr) % (n * 16) == 0;
        DistinctORegs7(@iptr, @iendptr, @optr, @tmp1, @tmp2, @tmp3, @tmp4);

    requires/ensures
        g.iheap != g.oheap;
        ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, taint);
        ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
        OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
        OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
        WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
         AESGCTRSeq(old(mem), g.iheap, g.iaddr, g.isize, g.isize));
{
    ghost var index   : int := 0;
    lemma_regdiff_loop_ge_uint128(iendptr, iptr, n);
    while (iptr < iendptr)
        invariant
            ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, taint);
            ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

            0 <= index <= g.isize;
            index == g.isize - (iendptr - iptr) / 16;
            iptr == g.iaddr + 16 * index;
            optr == g.oaddr + 16 * index;
            (iptr < iendptr) ==> g.isize >= 1; // Interesting that it can't prove this on entry wo ==>.
            (iendptr - iptr) % (n * 16) == 0;
            (iptr < iendptr) ==> (iendptr - iptr) >= (n * 16); // lemma above

            (iptr < iendptr) ==> 0 <= index + n - 1 < g.isize;
            (index < g.isize) ==> ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, g.isize, taint, iptr, index, n - 1);
            (index < g.isize) ==> ValidDstRegPtrs128(mem, g.oheap, g.oaddr, g.isize,        optr, index, n - 1);

            OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
            OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
            WritesReg128(mem, g.oheap, g.oaddr, g.isize, index, Public,
               AESGCTRSeq(old(mem), g.iheap, g.iaddr, g.isize, g.isize));
          decreases (iendptr - iptr);
    {
     // Bryan, constant folding issues.
        inline if (n == 1) {
          AESGCTRUnrolled(g, iptr, optr, tmp1, tmp2, tmp3, tmp4, index, 0);
         } else if (n == 2) {
          AESGCTRUnrolled(g, iptr, optr, tmp1, tmp2, tmp3, tmp4, index, 1);
         } else if (n == 3) {
          AESGCTRUnrolled(g, iptr, optr, tmp1, tmp2, tmp3, tmp4, index, 2);
         } else {
          AESGCTRUnrolled(g, iptr, optr, tmp1, tmp2, tmp3, tmp4, index, 3);
         }         
        ghost var iptr' := iptr;
        Add(iptr, const(n * 16));
        Add(optr, const(n * 16));
        index := index + n;
    }
  assert g.isize == index; 
  assert iendptr - iptr == 0;
}
*/

#verbatim
} // end module CGM
#endverbatim
