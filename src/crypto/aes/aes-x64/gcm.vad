include "../../../arch/x64/decls.vad"
include "../../../arch/x64/decls64.vad"
include{:verbatim} "../../../arch/x64/print.s.dfy"
include{:verbatim} "../../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "../../loopunroll/regions128.dfy"
include "../../loopunroll/regions128wrappers.vad"
include{:verbatim}   "../../loopunroll/copy128.dfy"
include "aes.vad" 
include{:verbatim} "gcm_helpers.i.dfy"
include{:verbatim} "../gcm3.s.dfy" 
include "gcm.proven.vad"
// for the instructions
include{:verbatim} "../../../lib/util/words_and_bytes.i.dfy"
include{:verbatim} "../../../lib/util/operations.i.dfy"
include "../../loopunroll/calleesave.vad"

#verbatim
module GCM {

import opened x64_def_s
import opened x64_vale_i
import opened x64_print_s
import opened dafny_wrappers_i
import opened x64_decls_i
import opened x64_decls64_i
import opened regions128wrappers
import opened GCMModule
import opened GCMHelpers
import opened GCMProven
import opened proof
import opened words_and_bytes_i
import opened operations_i
import opened aes_vale
import opened CalleeSaveRestore

#endverbatim

#verbatim
#endverbatim

// Serious bug here with lets in this revision. As Chris has fixed this, perhaps I should update?
procedure {:timeLimitMultiplier 3} AESGCTRLoopOverUnrolled
          (ghost g : GCMSpec,
           inline n : uint8nonzero)
    reads    rdi; rdx; r8; 
    modifies mem; efl; rsi; rcx; rax;
             xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15; 
             rbx; r9; r10; r11; r12; r13; r14; r15;
    requires
      let exp_key_ptr  := rdi; let iptr  := rsi; let iendptr := rdx; let optr := rcx; let ivptr := r8;  let ctr := rax;
      let items        := (old(iendptr) - old(iptr)) / 4;
      GCMSpecDynInit(g, exp_key_ptr, iptr, iendptr, optr, ivptr, mem);
      g.iaddr != g.oaddr; // Hmm, is this necessary?
      0 < n <= 8;
      (iendptr - iptr) % (n * 16) == 0;

    requires/ensures
        let exp_key_ptr  := rdi; let iptr  := rsi; let iendptr := rdx; let optr := rcx; let ivptr := r8;  let ctr := rax;
        GCMSpecDyn(g, exp_key_ptr, iptr, iendptr, optr, ivptr, mem);
        ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Public);
        ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
       OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
//       OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
//        WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
//         AESGCTRSeq(old(mem), g, g.isize));
{
    let exp_key_ptr  := rdi; let iptr  := rsi; let iendptr := rdx; let optr := rcx; let ivptr := r8;  let ctr := rax;
    let items        := (old(iendptr) - old(iptr)) / 4;
    ghost var index   : int := 0;
    // Bug Proof impedence mismatch: (iendptr - iptr) > 0 vs iptr < iendptr.
    lemma_regdiff_loop_ge_uint128'(iendptr, iptr, n);
    assert (iendptr - iptr) > 0 ==> (iendptr - iptr) >= (n * 16);
    assert (iendptr - iptr) > 0 ==> n - 1 < (iendptr - iptr) / 16;
    // Won't take lets here.
    while (rsi < rdx)
        invariant
            ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
            ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

            0 <= index <= g.isize;
            index == g.isize - (iendptr - iptr) / 16;
            iptr  == g.iaddr + 16 * index;
            optr  == g.oaddr + 16 * index;
            (iptr < iendptr) ==> g.isize >= 1; // Interesting that it can't prove this on entry wo ==>.
            (iendptr - iptr) % (n * 16) == 0;
            (iptr < iendptr) ==> (iendptr - iptr) >= (n * 16); // lemma above
            (iendptr - iptr) > 0 ==> index + n - 1 < (iendptr - iptr) / 16;

            (iptr < iendptr) ==> 0 <= index + n - 1 < g.isize;
            (index < g.isize) ==> 
               ValidSrcRegPtrs128(mem, g.iheap, g.iaddr, g.isize, Secret, iptr, index, n - 1);
            (index < g.isize) ==> 
               ValidDstRegPtrs128(mem, g.oheap, g.oaddr, g.isize,         optr, index, n - 1);

            OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
            OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
            WritesReg128(mem, g.oheap, g.oaddr, g.isize, index, Public, 
                                 AESGCTRSeq(old(mem), g, g.isize));
          decreases (iendptr - iptr);
    {
        assert rsi < rdx;
        assert iptr == rsi;
        assert iendptr == rdx;
        assert iptr < iendptr; // BUG Can't prove this, we have some serious let issue.
        assert iptr < iendptr ==> (iendptr - iptr) > 0;
        assert (iendptr - iptr) > 0;
        assert (iendptr - iptr) > 0 ==> index + n - 1 < (iendptr - iptr) / 16;
        assert index + n - 1 < (iendptr - iptr) / 16;
        AESGCTRUnrolled(g, index, n - 1);
        ghost var iptr' := iptr;
        // Won't take lets here.
        Add(rsi, const(n * 16));
        Add(rcx, const(n * 16));
        Add(rax, const(n));
        index := index + n;
    }
  assert g.isize == index; 
  assert iendptr - iptr == 0;
}


/* Proves blank under call.
// Encrypt, gctr only with the stack saved and the arguments in the expected place.
procedure AES128GCTREncrypt(ghost g : G,
          operand exp_key : uint64,
          operand iptr : uint64,
          operand iendptr : uint64,
          operand optr : uint64,
          operand ivptr : uint64,
          operand ctr : uint32)
    modifies mem; efl; rax; rdx; rcx; rdi; rsi; rbx; rbp; r8; r9; r10; r11; r12; r13; r14; r15; efl; stack;
    requires
     let items        := (old(iendptr) - old(iptr)) / 4;
     g.iaddr == old(iptr);
     g.oaddr == old(optr);
     g.isize  == items;
     g.iaddr != g.oaddr; // Is this strong enough?
     iendptr >= iptr; 
    requires/ensures
     g.iheap != g.oheap;
     ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
     ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);
    ensures
      stack == old(stack);
{
} 
*/

// Setup just the GCM CTR mode from a standard call.
//
// All MM registers are: rax, rbx, rcx, rdx, rbp, rsi, rdi, rsp, r8, r9, r10, r11, r12, r13, r14, r15.
// 
// GCC is giving us:
// exp_key      - rdi 
// iptr         - rsi
// iendptr      - rdx
// optr         - rcx
// IV           - r8d
// TO BE ADDED // AAD          - r9d 
// TO BE ADDED // TAG          - r10d - the mac, called TAG by some of the tests. Will this be on the stack?
//
// callee save restore frees up everything for us but:
// We need a 32 bit counter, which we'll put in rax.
// As rsp is the stack pointer, and a frame pointer, rbp may be in use.
// Leaving us: rax, rbx, r9, r10, r11, r12, r13, r14, r15.

// As we'd like to be able to unroll up to 8 way and we need 1 32 bit tmp counter per
// GCTR unfolding, we need up to 8 32 bit temporary registers: 
//
// We need a 96 bit IV in memory, 128 bit, zeros for the last 32, pointed to by r10;
// Then each unrolling gets two xmm registers for an eight way unrolling.
// The temporary registers will be supplied by name to all but final routine.
//
// Thus we own 100% of the 64 and 128 bit registers. 

// 

/*
procedure {:timeLimitMultiplier 3} AES128GCTREncryptStdcall(ghost g : GCMSpec)
    modifies mem; efl; rax; rdx; rcx; rdi; rsi; rbx; rbp; r8; r9; r10; r11; r12; r13; r14; r15; efl; stack;
    requires
     let exp_key      := rdi;
     let iptr         := rsi;
     let iendptr      := rdx;
     let optr         := rcx;
     let ivptr        := r8; // 96 high bits of IV and 32 bits of zero in memory in 128 bits.
     let ctr          := rax;
     let items        := (old(iendptr) - old(iptr)) / 4;
     g.iaddr == old(iptr);
     g.oaddr == old(optr);
     g.isize  == items;
     g.iaddr != g.oaddr; // Is this strong enough?
     iendptr >= iptr; 
     HasAtLeastFrames(stack, 1);

    requires/ensures
     g.iheap != g.oheap;
     ValidSrcReg128(mem, g.iheap, g.iaddr, g.isize, Secret);
     ValidDstReg128(mem, g.oheap, g.oaddr, g.isize);

    ensures
//        OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
//        OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
//        WritesReg128(mem, g.oheap, g.oaddr, g.isize, g.isize, Public,
//          AESGCTRSeq(old(mem), g.iheap, g.iaddr, g.isize, g.isize));
        // Ensure I don't mess up the old ptr, although C should not care.
     let optr    := rcx; optr == old(optr);
{
 CalleeSaveLinux();
 // Initialize CTR.
 Mov32(rax,const(1)); // It starts out at 1.
 AES128GCTREncrypt(g, rdi, rsi, rdx, rcx, r8, rax);
 CalleeRestoreLinux();
 EMMS(); // Intel says call this before a return if you are touching XMM.
}
*/

// Dummies for testing the test code.
procedure {:timeLimitMultiplier 3} AES128GCTREncryptStdcall(ghost g : GCMSpec) {}  
procedure {:timeLimitMultiplier 3} AES128GCTRDecryptStdcall(ghost g : GCMSpec) {} 

#verbatim
} // end module CGM
#endverbatim
