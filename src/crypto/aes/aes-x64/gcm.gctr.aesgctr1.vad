//include "../../../arch/x64/decls.vad"
//include "../../../arch/x64/decls64.vad"
//include{:verbatim} "../../../arch/x64/print.s.dfy"
//include{:verbatim} "../../../lib/util/dafny_wrappers.i.dfy"
//include{:verbatim} "../../loopunroll/regions128.dfy"
//include "../../loopunroll/regions128wrappers.vad"
//// for the instructions
//include{:verbatim} "../../../lib/util/words_and_bytes.i.dfy"
//include{:verbatim} "../../../lib/util/operations.i.dfy"

include "gcm.gctr.instructions.vad"
include "aes.vad"

#verbatim
module GCMGCTRAESGCTR1 {
 import opened GCMGCTRInstructions
 import opened aes_vale
 
#endverbatim

procedure {:timeLimitMultiplier 6} AESGCTR1(
          ghost g : GCMSpec, 
          operand exp_key_ptr : uint64,
          operand iptr        : uint64,
          operand iendptr     : uint64,
          operand optr        : uint64,
          operand ivptr       : uint64,
          operand ctr         : uint64,
          ghost    off        : uint64, 
          inline   add        : uint8,
          inout operand addtmp : uint64,   // Where we add the ctr.
          inout operand tmpctr : Quadword, // Where we build the ICB||CTR.
          inout operand tmp    : Quadword  // A tmp for AES plus where we put the plain text.
          )
   modifies mem; efl; 
   requires
    GCMRegUniqueWTmp(@exp_key_ptr, @iptr, @iendptr, @optr, @ivptr, @ctr, @addtmp);
    add <= 8;
    @tmp != @tmpctr;

   requires/ensures 
    0 <= ctr + add < 0x1_0000_0000;
    ValidDstReg128(mem, g.iheap, g.iaddr, g.isize);
    ctr == 2 + off;

   requires/ensures 
    GCMSpecDyn(g, exp_key_ptr, ivptr, mem);
    off + add < g.isize;
    ValidSrcRegPtrs128(mem, g.iheap,  g.iaddr,  g.isize,  Secret, iptr, off, add);
    ValidDstRegPtrs128(mem, g.oheap,  g.oaddr,  g.osize,          optr, off, add);
    WritesReg128(mem, g.oheap, g.oaddr, g.isize, off + add, Public, AESGCTRSeq(old(mem), g, g.isize));

   ensures 
    OnlyQuadwordHeapletChanged(old(mem), mem, g.oheap);
    OnlyWritesReg128(old(mem), mem, g.oheap, g.oaddr, g.isize);
    WritesReg128(mem, g.oheap, g.oaddr, g.isize, off + add + 1, Public, AESGCTRSeq(old(mem), g, g.isize));
{
   lemma_BitwiseAdd32();
   Mov32(addtmp, ctr);                               // Put the counter into a tmp.
   AddN32(addtmp, add);                              // Add our offset to it: 0, 1, ...
   assert 0 <= addtmp < 0x1_0000_0000;
   assert addtmp == ctr + add;
   BSwap32'(addtmp);                                 // CTR is byte swapped
   assert addtmp == bswap32(ctr + add);
   MOVD_xmm_rmm32(tmp, addtmp);                      // Put low 32 bits into an xmm tmp.
   assert tmp == Quadword(bswap32(ctr + add), 0, 0, 0); 
//   PSLLDQ(tmp,12);                                  // Put them high, but can't prove this due to 128 bv issues.
   Pshufd(tmp,tmp,0x15);                              // 0b_0001_0101 high gets zero, others get a zero.
   assert tmp == Quadword(0, 0, 0, bswap32(ctr + add));   // just for readers.
   Load128'(tmpctr, ivptr, 0, Secret, g.ivheap);     // Get the IV+32 0s from memory.
   lemma_QuadwordOrZeros(tmpctr, tmp);
   POR(tmpctr, tmp);                                // ICB (96 bits) || ctr for this offset.
   assert tmpctr == Quadword(g.ICB.lo, g.ICB.mid_lo, g.ICB.mid_hi, bswap32(ctr + add)); // just for readers.
   lemma_CBAt_fixed(off + add, g.ICB);
   assert tmpctr == CB(off + add, g.ICB);
   AES128EncryptOneBlockOp(g.key, tmpctr, g.exp_key, Secret, tmpctr, tmp, exp_key_ptr, g.exp_key_heap); // Encrypt the counter back into tmpctr;
   LoadArray128(tmp, iptr, add, Secret, g.iheap);    // Load the plaintext into tmp.
   Pxor(tmp, tmpctr);                                // Xor the encrypted counter with the plaintext.
   StoreArray128(optr, tmp, add, Public, g.oheap);   // Write it back to the output.
}

#verbatim
}
#endverbatim
