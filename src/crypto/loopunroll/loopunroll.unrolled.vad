/*
  Do some testing on building and proving unrolled loops.
  Basic results.

*/

include "../../arch/x64/decls.vad"
include "../../arch/x64/decls64.vad"
include{:verbatim} "../../arch/x64/print.s.dfy"
include{:verbatim} "../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "loopunroll.s.dfy" 
include{:verbatim} "seqcomp.s.dfy" 
include{:verbatim} "addrlogic.s.dfy" 
include "loopunroll.proven.vad"

#verbatim
module LoopUnrollUnrolled {

import opened x64_def_s
import opened x64_vale_i
import opened x64_print_s
import opened dafny_wrappers_i
import opened x64_decls_i
import opened x64_decls64_i
import opened LoopUnrollModule
import opened seqcomp
import opened addrlogic
import opened LoopUnrollProven

#endverbatim


// This is the best version of all. Hand unrlled yet recursively unrollable.
procedure {:recursive} {:timeLimitMultiplier 6}  IncrementUint64Unrolled (ghost id : heaplet_id, inline step : nat)
    modifies mem; efl; rdx; rcx; r9; r10; r11; r12; r13; r14; r15; rbx;
    reads r8;

    requires 0 <= step < 8;
    requires/ensures ValidSrcAlAddrs64(mem, id, addrs64(old(r8), step + 1), Public);
    ensures WritesAddrs64(old(mem), mem, id,  addrs64(old(r8), step + 1), Public,
                  Plus8(old(mem), id, addrs64(old(r8), step + 1), step + 1));
    ensures OnlyWritesAddrs64(old(mem), mem, id, addrs64(old(r8), step + 1));

{
  lemma_BitwiseAdd64();
  lemma_ValidSrcAlAddrs64(mem, id, addrs64(old(r8), step + 1), Public);

  inline if (step == 7) {
    IncrementUint64Unrolled(id, step - 1);
    ghost var mem0 := mem; 
    ReadIncrStore(r8, r9,  id,  7);
    lemma_Writes_OnlyWrites_Range_Addr_Ext(old(mem), mem0, mem, id, old(r8), 7, Public,
          Plus8(old(mem), id, addrs64(old(r8), 8), 8));
  } else if (step == 6) {
    IncrementUint64Unrolled(id, step - 1);
    ghost var mem0 := mem; 
    ReadIncrStore(r8, r10,  id, 6);
    lemma_Writes_OnlyWrites_Range_Addr_Ext(old(mem), mem0, mem, id, old(r8), 6, Public,
          Plus8(old(mem), id, addrs64(old(r8), 7), 7));
  } else  if (step == 5) { 
    IncrementUint64Unrolled(id, step - 1);
    ghost var mem0 := mem; 
    ReadIncrStore(r8, r11,  id, 5);
    lemma_Writes_OnlyWrites_Range_Addr_Ext(old(mem), mem0, mem, id, old(r8), 5, Public,
          Plus8(old(mem), id, addrs64(old(r8), 6), 6));
  } else if (step == 4) {
    IncrementUint64Unrolled(id, step - 1);
    ghost var mem0 := mem; 
    ReadIncrStore(r8, r12,  id, 4);
    lemma_Writes_OnlyWrites_Range_Addr_Ext(old(mem), mem0, mem, id, old(r8), 4, Public,
          Plus8(old(mem), id, addrs64(old(r8), 5), 5));
  } else if (step == 3) {
    IncrementUint64Unrolled(id, step - 1);
    ghost var mem0 := mem; 
    ReadIncrStore(r8, r13,  id, 3);
    lemma_Writes_OnlyWrites_Range_Addr_Ext(old(mem), mem0, mem, id, old(r8), 3, Public,
          Plus8(old(mem), id, addrs64(old(r8), 4), 4));
  } else if (step == 2) {
    IncrementUint64Unrolled(id, step - 1);
    ghost var mem0 := mem; 
    ReadIncrStore(r8, r14,  id, 2);
    lemma_Writes_OnlyWrites_Range_Addr_Ext(old(mem), mem0, mem, id, old(r8), 2, Public,
          Plus8(old(mem), id, addrs64(old(r8), 3), 3));
  } else if (step == 1) {
    IncrementUint64Unrolled(id, step - 1);
    ghost var mem0 := mem; 
    ReadIncrStore(r8, r15,  id, 1);
    lemma_Writes_OnlyWrites_Range_Addr_Ext(old(mem), mem0, mem, id, old(r8), 1, Public,
          Plus8(old(mem), id, addrs64(old(r8), 2), 2));
  } else   if (step == 0) {                                    
    ghost var mem0 := mem; 
    ReadIncrStore(r8, rbx, id, 0); 
    lemma_Writes_OnlyWrites_Range_Addr_Ext(old(mem), mem0, mem, id, old(r8), 0, Public,
          Plus8(old(mem), id, addrs64(old(r8), 1), 1));
 }
}

#verbatim
} 
#endverbatim
