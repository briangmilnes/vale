/*

  This file provides wrappers for Load and Store instructions to allow us
 to call Loads and Stores that are specified by regions instead of just ValidAddrs.

*/

include "../../arch/x64/decls.vad"
include "../../arch/x64/decls64.vad"
include{:verbatim} "../../arch/x64/def.s.dfy"
include{:verbatim} "../../arch/x64/vale.i.dfy"

include{:verbatim} "regions128.dfy"

#verbatim
module regions128wrappers {

import opened x64_decls_i
import opened x64_decls64_i
import opened x64_def_s
import opened x64_vale_i

import opened regions128
#endverbatim

procedure{:refined}{:bridge} LoadArray128(out operand dst:Quadword, operand src:uint64, inline i:int,
    inline taint:taint, ghost id:heaplet_id)
    reads mem;
    modifies efl;
    requires/ensures
        mem?[id];
        mem[id] is QuadwordHeaplet;
        mem[id].quads?[addr128(old(src), i)];
        mem[id].quads[addr128(old(src), i)].t == taint;
    ensures
        dst == mem[id].quads[addr128(old(src), i)].v;
{
    Load128(dst, src, 16 * i, taint, id);
}
 
procedure{:refined}{:bridge} StoreArray128(operand dst:uint64, operand src:Quadword, inline i:int,
    inline taint:taint, ghost id:heaplet_id)
    modifies mem; efl;
    requires
        mem?[id];
        mem[id] is QuadwordHeaplet;
        mem[id].quads?[addr128(dst, i)];
    ensures
        mem == old(mem)[id := old(mem)[id].(quads := old(mem)[id].quads[addr128(dst, i) := QuadwordHeapletEntry(src, taint)])];
{
    Store128(dst, src, 16 * i, taint, id);
}
 
procedure{:refined}{:bridge} LoadArrayPtr128(out operand dst:Quadword, operand src:uint64, ghost i:int,
    inline taint:taint, ghost id:heaplet_id)
    reads mem;
    modifies efl;
    requires/ensures
        mem?[id];
        mem[id] is QuadwordHeaplet;
        mem[id].quads?[addr128(old(src) - 16 * i, i)];
        mem[id].quads[addr128(old(src) - 16 * i, i)].t == taint;
    ensures
        dst == mem[id].quads[addr128(old(src) - 16 * i, i)].v;
{
    Load128(dst, src, 0, taint, id);
}
 
procedure{:refined}{:bridge} StoreArrayPtr128(operand dst:uint64, operand src:Quadword, ghost i:int,
    inline taint:taint, ghost id:heaplet_id)
        
    modifies mem; efl;
    requires
        mem?[id];
        mem[id] is QuadwordHeaplet;
        mem[id].quads?[addr128(dst - 16 * i, i)];
    ensures
        mem == old(mem)[id := old(mem)[id].(quads := old(mem)[id].quads[addr128(dst - 16 * i, i) := QuadwordHeapletEntry(src, taint)])];
{
    Store128(dst, src, 0, taint, id);
}
 
// A wrapper for Add64 to allow inline operands to evaluate in non refined procedures.
procedure{:refined}{:bridge} Add(inout operand dst:uint64, operand src:uint64)
    requires
        src + dst < 0x1_0000_0000_0000_0000;
    modifies
        efl;
    ensures
        dst == old(dst) + old(src);
{
    Add64(dst, src);
}

// The same.
procedure{:refined}{:bridge} Mov(inout operand dst:uint64, operand src:uint64)
    ensures
        dst == old(src);
{
    Mov64(dst, src);
}

#verbatim
} 
#endverbatim
