/*

    Build a real regions logic.

*/

include "../../arch/x64/decls.vad"
include "../../arch/x64/decls64.vad"
include{:verbatim} "../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "../../arch/x86/def.s.dfy"
include{:verbatim} "../../arch/x86/vale.i.dfy"
include "../../arch/x86/decls.vad"

include "regions.proven.vad"
include{:verbatim} "regions.dfy"

#verbatim
module regions {

import opened dafny_wrappers_i
import opened x86def_s_temp = x86_def_s
import opened x86vale_temp = x86_vale_i
import opened x86decls_temp = x86_decls_i
import opened regionsproven
import opened regionsdfy

#endverbatim

// In this style we are always specifying a full sequence of the input and an index to which
// it has been written.

/*
// Work on adding predicates instead of raw definitions.
procedure{:refined}{:timeLimitMultiplier 2} Copy64Pred(inline taint:taint, ghost src_id:heaplet_id, ghost dst_id:heaplet_id)
    reads
        esi; edi;
    modifies
       mem; eax; ebx; ecx; edx; ebp;

    requires/ensures
        src_id != dst_id;
        ValidSrcReg32(mem, src_id, esi, 16, taint);
        ValidDstReg32(mem, dst_id, edi, 16);

    ensures
        OnlyHeapletChanged(old(mem), mem, dst_id);
        OnlyWritesReg32(old(mem), mem, dst_id, edi, 16);
        WritesReg32(mem, dst_id, edi, 16, 16, taint,
          Copy32Seq(old(mem), src_id, old(esi), 16, 16));
{
    LoadArray32(eax, esi, 0, taint, src_id);
    LoadArray32(ebx, esi, 1, taint, src_id);
    LoadArray32(ecx, esi, 2, taint, src_id);
    LoadArray32(edx, esi, 3, taint, src_id);
    LoadArray32(ebp, esi, 4, taint, src_id);
    StoreArray32(edi, eax, 0, taint, dst_id);
    StoreArray32(edi, ebx, 1, taint, dst_id);
    StoreArray32(edi, ecx, 2, taint, dst_id);
    StoreArray32(edi, edx, 3, taint, dst_id);
    StoreArray32(edi, ebp, 4, taint, dst_id);
    LoadArray32(eax, esi, 5, taint, src_id);
    LoadArray32(ebx, esi, 6, taint, src_id);
    LoadArray32(ecx, esi, 7, taint, src_id);
    LoadArray32(edx, esi, 8, taint, src_id);
    LoadArray32(ebp, esi, 9, taint, src_id);
    StoreArray32(edi, eax, 5, taint, dst_id);
    StoreArray32(edi, ebx, 6, taint, dst_id);
    StoreArray32(edi, ecx, 7, taint, dst_id);
    StoreArray32(edi, edx, 8, taint, dst_id);
    StoreArray32(edi, ebp, 9, taint, dst_id);
    LoadArray32(eax, esi, 10, taint, src_id);
    LoadArray32(ebx, esi, 11, taint, src_id);
    LoadArray32(ecx, esi, 12, taint, src_id);
    LoadArray32(edx, esi, 13, taint, src_id);
    LoadArray32(ebp, esi, 14, taint, src_id);
    StoreArray32(edi, eax, 10, taint, dst_id);
    StoreArray32(edi, ebx, 11, taint, dst_id);
    StoreArray32(edi, ecx, 12, taint, dst_id);
    StoreArray32(edi, edx, 13, taint, dst_id);
    StoreArray32(edi, ebp, 14, taint, dst_id);
    LoadArray32(eax, esi, 15, taint, src_id);
    StoreArray32(edi, eax, 15, taint, dst_id);
}
*/

/*
// This loop has a fixed size and uses too many registers.
procedure Copy64Loop(inline taint:taint, ghost src_id:heaplet_id, ghost dst_id:heaplet_id)
    reads
        esi; edi;
    modifies
        mem; efl; eax; ebx; ecx; edx;
    requires/ensures
        src_id != dst_id;
        ValidSrcReg32(mem, src_id, esi, 16, taint);
        ValidDstReg32(mem, dst_id, edi, 16);
    ensures
        OnlyHeapletChanged(old(mem), mem, dst_id);
        OnlyWritesReg32(old(mem), mem, dst_id, edi, 16);
        WritesReg32(mem, dst_id, edi, 16, 16, taint, 
           Copy32Seq(old(mem), src_id, old(esi), 16, 16));
{
    Mov(ebx, esi);
    Mov(ecx, edi);
    Mov(edx, esi);
    Add(edx, 64);
    ghost var index:int := 0;
    while (ebx < edx)
        invariant
            0 <= index <= 16;
            ebx == esi + 4 * index;
            ecx == edi + 4 * index;
            edx == esi + 4 * 16;
            (ebx < edx) ==> ValidSrcRegPtr32(mem, src_id, esi, 16, taint, ebx, index);
            (ebx < edx) ==> ValidDstRegPtr32(mem, dst_id, edi, 16, ecx, index);
            OnlyHeapletChanged(old(mem), mem, dst_id);
            OnlyWritesReg32(old(mem), mem, dst_id, edi, 16);
            WritesReg32(mem, dst_id, edi, 16, index, taint,
               Copy32Seq(old(mem), src_id, old(esi), 16, 16));
        decreases (16 - index);
    {
        LoadArrayPtr32(eax, ebx, index, taint, src_id);
        StoreArrayPtr32(ecx, eax, index, taint, dst_id);
        Add(ebx, 4);
        Add(ecx, 4);
        index := index + 1;
    }
}
*/

/*
// This loop uses too many registers.
// Input is esi, copied into ebx.
// Aribtrary aligned input end is in edx.
// Output is edi.
procedure {:timeLimitMultiplier 1} Copy64LoopArbitraryAlignedSize
          (inline taint:taint, ghost src_id:heaplet_id, ghost dst_id:heaplet_id)
    let items :=  (old(edx) - old(esi)) / 4;
    reads
        esi; edi; edx;
    modifies
        mem; efl; eax; ebx; ecx;
    requires/ensures
        edx >= esi; 
        (edx - esi) % 4 == 0;
        src_id != dst_id;
        ValidSrcReg32(mem, src_id, esi, items, taint);
        ValidDstReg32(mem, dst_id, edi, items);
    ensures
        OnlyHeapletChanged(old(mem), mem, dst_id);
        OnlyWritesReg32(old(mem), mem, dst_id, edi, items);
        WritesReg32(mem, dst_id, edi, items, items, taint, 
         Copy32Seq(old(mem), src_id, old(esi), items, items));
{
    Mov(ebx, esi);
    Mov(ecx, edi);
    ghost var index : int := 0;
    while (ebx < edx)
        invariant
            0 <= index <= items;
            ebx == esi + 4 * index;
            ecx == edi + 4 * index;
            (ebx < edx) ==> ValidSrcRegPtr32(mem, src_id, esi, items, taint, ebx, index);
            (ebx < edx) ==> ValidDstRegPtr32(mem, dst_id, edi, items, ecx, index);
            OnlyHeapletChanged(old(mem), mem, dst_id);
            OnlyWritesReg32(old(mem), mem, dst_id, edi, items);
            WritesReg32(mem, dst_id, edi, items, index, taint,
               Copy32Seq(old(mem), src_id, old(esi), items, items));
        decreases (items - index);
    {
        LoadArrayPtr32 (eax, ebx, index, taint, src_id);
        StoreArrayPtr32(ecx, eax, index, taint, dst_id);
        Add(ebx, 4);
        Add(ecx, 4);
        index := index + 1;
    }
}
*/

/*
// Input is esi, modified.
// Aribtrary aligned input end is in edx.
// Output is edi, modified.
// Essentially, to keep register pressure down we will caller save and use our
// input and output registers to move along our data.
// This leaves more registers for loop unrolling.
procedure {:timeLimitMultiplier 1} Copy64LoopArbitraryAlignedSizeModifyInpOutPtr
          (inline taint:taint, ghost src_id:heaplet_id, ghost dst_id:heaplet_id)
    let items :=  (old(edx) - old(esi)) / 4;
    reads
        edx;
    modifies
        mem; esi; edi; efl; eax;
    requires
        edx >= esi; 
        (edx - esi) % 4 == 0;

    requires/ensures
        src_id != dst_id;
        ValidSrcReg32(mem, src_id, old(esi), items, taint);
        ValidDstReg32(mem, dst_id, old(edi), items);

    ensures
        OnlyHeapletChanged(old(mem), mem, dst_id);
        OnlyWritesReg32(old(mem), mem, dst_id, old(edi), items);
        WritesReg32(mem, dst_id, old(edi), items, items, taint,
         Copy32Seq(old(mem), src_id, old(esi), items, items));
{
    ghost var index : int := 0;
    while (esi < edx)
        invariant
            0 <= index <= items;
            esi == old(esi) + 4 * index;
            edi == old(edi) + 4 * index;
            (esi < edx) ==> ValidSrcRegPtr32(mem, src_id, old(esi), items, taint, esi, index);
            (esi < edx) ==> ValidDstRegPtr32(mem, dst_id, old(edi), items, edi, index);
            OnlyHeapletChanged(old(mem), mem, dst_id);
            OnlyWritesReg32(old(mem), mem, dst_id, old(edi), items);
            WritesReg32(mem, dst_id, old(edi), items, index, taint,
               Copy32Seq(old(mem), src_id, old(esi), items, items));
        decreases ((items) - index);
    {
        LoadArrayPtr32 (eax, esi, index, taint, src_id);
        StoreArrayPtr32(edi, eax, index, taint, dst_id);
        Add(esi, 4);
        Add(edi, 4);
        index := index + 1;
    }
}
*/

// Use the RegPtr offset style.
procedure {:bridge} {:timeLimitMultiplier 3} Copy32 
         (ghost src_id    : heaplet_id, 
          ghost dst_id    : heaplet_id,
          ghost   src     : uint32,  
          ghost   dst     : uint32,
          ghost  reg_size : nat,
          inline taint    : taint, 
          operand srcptr  : uint32,
          operand dstptr  : uint32,
          ghost   off     : nat,
          inout operand tmp : uint32)

    modifies mem; efl;
    requires IsOReg(@srcptr) && IsOReg(@dstptr) && IsOReg(@tmp);
             @srcptr != @dstptr  && @srcptr != @tmp  && @dstptr != @tmp;

    requires/ensures 
        off < reg_size;
        ValidSrcRegPtr32(mem, src_id, src, reg_size, taint, srcptr, off);
        ValidDstRegPtr32(mem, dst_id, dst, reg_size,        dstptr, off);
        WritesReg32(mem, dst_id, dst, reg_size, off, taint,
                   Copy32Seq(old(mem), src_id, src, reg_size, reg_size));

    ensures 
         OnlyHeapletChanged(old(mem), mem, dst_id);
         OnlyWritesReg32(old(mem), mem, dst_id, dst, reg_size);
         WritesRegPtrs32(mem, dst_id, dst, reg_size, taint, dstptr, off, 1,
                          Copy32Seq(mem, src_id, src, reg_size, reg_size));
         WritesReg32(mem, dst_id, dst, reg_size, off + 1, taint,
                   Copy32Seq(old(mem), src_id, src, reg_size, reg_size));
{
   LoadArray32 (tmp,    srcptr, 0, taint, src_id);
   StoreArray32(dstptr,    tmp, 0, taint, dst_id);
}     

/*
// Input is esi, modified.
// Aribtrary aligned input end is in edx.
// Output is edi, modified.
// Tmp is eax;
procedure {:timeLimitMultiplier 1} CopyLoopArbitraryAlignedSizeModifyInpOutPtrCall
          (inline taint:taint, ghost src_id:heaplet_id, ghost dst_id:heaplet_id)
    let items :=  (old(edx) - old(esi)) / 4;
    reads
        edx;
    modifies
        efl; mem; esi; edi; eax;
    requires
        edx >= esi; 
        (edx - esi) % 4 == 0;
    requires/ensures
        src_id != dst_id;
        ValidSrcReg32(mem, src_id, old(esi), items, taint);
        ValidDstReg32(mem, dst_id, old(edi), items);
    ensures
        OnlyHeapletChanged(old(mem), mem, dst_id);
        OnlyWritesReg32(old(mem), mem, dst_id, old(edi), items);
        WritesReg32(mem, dst_id, old(edi), items, items, taint,
         Copy32Seq(old(mem), src_id, old(esi), items, items));
{
    ghost var items' : nat := (old(edx) - old(esi)) / 4;
    ghost var index : int := 0;
    while (esi < edx)
        invariant
            ValidSrcReg32(mem, src_id, old(esi), items, taint);
            ValidDstReg32(mem, dst_id, old(edi), items);

            0 <= index <= items;
            esi == old(esi) + 4 * index;
            edi == old(edi) + 4 * index;
  
            (esi < edx) ==> ValidSrcRegPtr32(mem, src_id, old(esi), items, taint, esi, index);
            (esi < edx) ==> ValidDstRegPtr32(mem, dst_id, old(edi), items, edi, index);

            OnlyHeapletChanged(old(mem), mem, dst_id);
            OnlyWritesReg32(old(mem), mem, dst_id, old(edi), items);
            WritesReg32(mem, dst_id, old(edi), items, index, taint,
               Copy32Seq(old(mem), src_id, old(esi), items, items));
        decreases (items - index);
    {
        Copy32(src_id, dst_id, old(esi), old(edi), items', taint, esi, edi, index, eax);
        Add(esi, 4);
        Add(edi, 4);
        index := index + 1;
    }
}
*/

// Input is esi, Output is edi, up to four unrollings.
procedure {:recursive} {:timeLimitMultiplier 1} Copy32Unrolled
         (ghost src_id:heaplet_id, ghost dst_id:heaplet_id, 
          ghost srcbase : uint32, ghost dstbase : uint32, 
          ghost reg_size : nat, 
          ghost off : nat, inline step : nat, inline taint:taint)

    reads esi; edi;
    modifies mem; efl; eax; ebx; ecx; edx; ebp; 

    requires
       1 <= reg_size;              // Must have at least on address to write.
       off + step + 1 <= reg_size; // And more than step as starts at zero.
       0 <= step < 3;

    requires/ensures 
           src_id != dst_id;
           step < reg_size;
           ValidSrcRegPtr32(mem, src_id, old(esi), reg_size, taint, esi, off + step);
           ValidDstRegPtr32(mem, dst_id, old(edi), reg_size,        edi, off + step);
           WritesReg32(mem, dst_id, old(edi), reg_size, off, taint,
                 Copy32Seq(old(mem), src_id, old(esi), reg_size, reg_size));
    ensures
         OnlyHeapletChanged(old(mem), mem, dst_id);
         OnlyWritesReg32(old(mem), mem, dst_id, edi, reg_size);
         // I wrote step + 1 new words.
         WritesRegPtrs32(mem, dst_id, old(edi), reg_size, taint, edi, off, step + 1,
                   Copy32Seq(old(mem), src_id, old(esi), reg_size, reg_size));
         // This means I wrote off + step + 1 of the output in total.
         WritesReg32(mem, dst_id, old(edi), reg_size, off + step + 1, taint,
                   Copy32Seq(old(mem), src_id, old(esi), reg_size, reg_size));
{
  inline if (step == 3) {
       Copy32Unrolled(src_id, dst_id, old(esi),  old(edi), reg_size, off, step - 1, taint);
       Copy32(src_id, dst_id, old(esi), old(edi), reg_size, taint, esi, edi, 3, edx);
  } else if (step == 2) {
       Copy32Unrolled(src_id, dst_id, old(esi),  old(edi), reg_size, off, step - 1, taint);
       Copy32(src_id, dst_id, old(esi), old(edi), reg_size, taint, esi, edi, 2, ecx);
  } else  if (step == 1) {
       Copy32Unrolled(src_id, dst_id, old(esi),  old(edi), reg_size, off, step - 1, taint);
       Copy32(src_id, dst_id, old(esi), old(edi), reg_size, taint, esi, edi, 1, ebx);
   } else if (step == 0) {                                    
       Copy32(src_id, dst_id, old(esi), old(edi), reg_size, taint, esi, edi, 0, eax);
   }
}
  
// Input is esi, modified.
// Aribtrary aligned input end is in edx.
// Output is edi, modified.
// Try calling the unrolled loop with a single step.
procedure {:timeLimitMultiplier 1} CopyLoopOverUnrolled1
          (inline taint:taint, ghost src_id:heaplet_id, ghost dst_id:heaplet_id)
    let items :=  (old(edx) - old(esi)) / 4;
    reads
        edx;
    modifies mem; efl; eax; ebx; ecx; edx; ebp; esi; edi;
    requires
        edx >= esi; 
        (edx - esi) % 4 == 0;
    requires/ensures
        src_id != dst_id;
        ValidSrcReg32(mem, src_id, old(esi), items, taint);
        ValidDstReg32(mem, dst_id, old(edi), items);

    ensures
        OnlyHeapletChanged(old(mem), mem, dst_id);
        OnlyWritesReg32(old(mem), mem, dst_id, old(edi), items);
        WritesReg32(mem, dst_id, old(edi), items, items, taint,
         Copy32Seq(old(mem), src_id, old(esi), items, items));
{
    ghost var index : int := 0;
    while (esi < edx)
        invariant
            ValidSrcReg32(mem, src_id, old(esi), items, taint);
            ValidDstReg32(mem, dst_id, old(edi), items);

            0 <= index <= items;
            esi == old(esi) + 4 * index;
            edi == old(edi) + 4 * index;

            (esi < edx) ==> items >= 1; // Interesting that it can't prove this on entry wo ==>.
            (esi < edx) ==> ValidSrcRegPtr32(mem, src_id, old(esi), items, taint, esi, index);
            (esi < edx) ==> ValidDstRegPtr32(mem, dst_id, old(edi), items,        edi, index);

            OnlyHeapletChanged(old(mem), mem, dst_id);
            OnlyWritesReg32(old(mem), mem, dst_id, old(edi), items);
            WritesReg32(mem, dst_id, old(edi), items, index, taint, 
               Copy32Seq(old(mem), src_id, old(esi), items, items));
        decreases (items - index);
    {
        assert ValidSrcRegPtr32(mem, src_id, old(esi), items, taint, esi, index + 0);
        assert ValidDstRegPtr32(mem, dst_id, old(edi), items,        edi, index + 0);
        assert old(esi) + 4 * index < 0x1_0000_0000;
        assert WritesReg32(mem, dst_id, old(edi), items, index, taint,
               Copy32Seq(old(mem), src_id, old(esi), items, items));
        Copy32Unrolled(src_id, dst_id, old(esi), old(edi), items, index, 0, taint);
        Add(esi, 4);
        Add(edi, 4);
        index := index + 1;
    }
}


#verbatim
}
#endverbatim
