/*

    Build a real regions logic.

*/

include "../../arch/x64/decls.vad"
include "../../arch/x64/decls64.vad"
include{:verbatim} "../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "../../arch/x86/def.s.dfy"
include{:verbatim} "../../arch/x86/vale.i.dfy"

include "regions.proven.vad"
include{:verbatim} "regions.dfy"

#verbatim
module regions {

import opened dafny_wrappers_i
import opened x86def_s_temp = x86_def_s
import opened x86vale_temp = x86_vale_i
import opened x86decls_temp = x86_decls_i
import opened regionsproven
import opened regionsdfy

import opened declsX86vale = x86_vale_i
import opened x86_decls_i_parser_help_i = dafny_wrappers_i
import opened words_and_bytes_i_temp = words_and_bytes_i
import opened operations_i_temp = operations_i


#endverbatim

procedure CopyLoopOverUnrolled4WithTail
          (inline taint:taint, ghost src_id:heaplet_id, ghost dst_id:heaplet_id)
    let items :=  (old(edx) - old(esi)) / 4;
    reads edx;
    modifies mem; efl; eax; ebx; ecx; edx; ebp; esi; edi;
    requires
        edx >= esi; 
        (edx - esi) % 16 == 0;
        old(esi) != old(edi);

    requires/ensures
        src_id != dst_id;
        ValidSrcReg32(mem, src_id, old(esi), items, taint);
        ValidDstReg32(mem, dst_id, old(edi), items);

    ensures
        OnlyHeapletChanged(old(mem), mem, dst_id);
        OnlyWritesReg32(old(mem), mem, dst_id, old(edi), items);
        WritesReg32(mem, dst_id, old(edi), items, items, taint,
         Copy32Seq(old(mem), src_id, old(esi), items, items));
{
    ghost var index   : int := 0;
    ghost var srcbase : uint32 := old(esi);
    ghost var dstbase : uint32 := old(edi);
    lemma_regdiff_loop_ge(edx, esi, 16);
    while (esi < edx)
        invariant
            ValidSrcReg32(mem, src_id, srcbase, items, taint);
            ValidDstReg32(mem, dst_id, dstbase, items);

            0 <= index <= items;
            index == items - (edx - esi) / 4;
            esi == srcbase + 4 * index;
            edi == dstbase + 4 * index;
            (esi < edx) ==> items >= 1; // Interesting that it can't prove this on entry wo ==>.
            (edx - esi) % 16 == 0;
            (esi < edx) ==> (edx - esi) >= 16; // lemma above

            (index < items) ==> ValidSrcRegPtrs32(mem, src_id, srcbase, items, taint, esi, index, 1);
            (index < items) ==> ValidDstRegPtrs32(mem, dst_id, dstbase, items,        edi, index, 1);

            OnlyHeapletChanged(old(mem), mem, dst_id);
            OnlyWritesReg32(old(mem), mem, dst_id, dstbase, items);
            WritesReg32(mem, dst_id, dstbase, items, index, taint,
               Copy32Seq(old(mem), src_id, srcbase, items, items));
          decreases (edx - esi);
    {
        Copy32Unrolled(src_id, dst_id, srcbase, dstbase, items, index, 3, taint);
        Add(esi, 16);
        Add(edi, 16);
        index := index + 4;
    }
  assert items == index; 
  assert edx - esi == 0;
}


#verbatim
}
#endverbatim
