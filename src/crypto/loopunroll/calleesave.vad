/*

  This demonstrates x64 callee save using push and pop of r64 registers.
  Brian Milnes 31 Aug 2017

*/

/* 
  Vale seems to be using the following calling conventions:

  https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions

  Arch  OS       Convention                            Arguments                                 Caller saved
  x86
     Linux      cdecl                                 arguments on the stack                  EAX, ECX, and EDX
     Windows    cdecl?stdcall                         arguments on the stack                        ?
  x64 
     Linux      System V AMD64 ABI                    RDI, RSI, RDX, RCX, R8, R9, XMM0â€“7            ?
     Windows    Microsoft x64 calling convention      RCX/XMM0, RDX/XMM1, R8/XMM2, R9/XMM3          ?
 
  But see below, GCC is acatually giving us: rax; rsi; rdx; rcx; r10; r9; rdi; r8;

 And we add to this the complexity of the ABIs

https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-r252.pdf
https://msdn.microsoft.com/en-us/library/ew5tede7.aspx

So callee save restore works differently on Linux and Windows.

On Linux: pg 23
   adjust RSP must by 16 byte aligned.
   save rbx, rbp, r12, r13, r14, r15
   xmm registers do not need to be saved.

The stack must be aligned on a 16 byte boundary when a function is called,
so %rsp must be divisible by 16 immediately preceding any 'call' instruction

 So if we are not going to call OUT of Vale into C then we are OK to use Push/Pop.

 Otherwise 
  subq $16, %rsp
  movq %rsi, (%rsp)
  movq %r12, (%rsp+8)

On Windows:

*/

include "../../arch/x64/decls.vad"
include "../../arch/x64/decls64.vad"
include{:verbatim} "../../arch/x64/print.s.dfy"
include{:verbatim} "../../lib/util/dafny_wrappers.i.dfy"

#verbatim
module CalleeSaveRestore {

import opened x64_def_s
import opened x64_vale_i
import opened x64_print_s
import opened dafny_wrappers_i
import opened x64_decls_i
import opened x64_decls64_i

#endverbatim

procedure {:refined} {:bridge} CalleeSaveLinux()
  reads rbx; rbp; r12; r13; r14; r15;
  requires HasAtLeastFrames(stack, 1);
  modifies efl; stack;
  ensures  
   HasAtLeastFrames(stack, 7);
   HasAtLeastN64BitFrames(stack, 6);
   rbx == lowerUpper64trans(stack[5][0], stack[5][1]); 
   rbp == lowerUpper64trans(stack[4][0], stack[4][1]); 
   r12 == lowerUpper64trans(stack[3][0], stack[3][1]); 
   r13 == lowerUpper64trans(stack[2][0], stack[2][1]); 
   r14 == lowerUpper64trans(stack[1][0], stack[1][1]); 
   r15 == lowerUpper64trans(stack[0][0], stack[0][1]);
{
  // Save the registers, but we are NOT OK to call out of Vale to C.
  PUSH(rbx); PUSH(rbp); PUSH(r12); PUSH(r13); PUSH(r14); PUSH(r15);  
} 


procedure {:refined} {:bridge} CalleeRestoreLinux()
  requires/ensures HasAtLeastFrames(stack, 1);
  requires 
   HasAtLeastFrames(stack, 7); // We require one frame at all times for a valid state.
   HasAtLeastN64BitFrames(stack, 6);
  modifies rbx; rbp; r12; r13; r14; r15; efl; stack;
  ensures  
   rbx == old(lowerUpper64trans(stack[5][0], stack[5][1]));
   rbp == old(lowerUpper64trans(stack[4][0], stack[4][1]));
   r12 == old(lowerUpper64trans(stack[3][0], stack[3][1]));
   r13 == old(lowerUpper64trans(stack[2][0], stack[2][1]));
   r14 == old(lowerUpper64trans(stack[1][0], stack[1][1]));
   r15 == old(lowerUpper64trans(stack[0][0], stack[0][1]));
{
  lemma_lower_upper_trans(); // Why is this needed? 
  // Restore them.
  POP(r15); POP(r14); POP(r13); POP(r12); POP(rbp); POP(rbx); 
} 

procedure {:refined} {:bridge} CalleeSaveRestoreLinux()
  requires/ensures HasAtLeastFrames(stack, 1);
  modifies rbx; rbp; r12; r13; r14; r15; efl; stack;
  ensures  
   rbx == old(rbx);
   rbp == old(rbp);
   r12 == old(r12);
   r13 == old(r13);
   r14 == old(r14);
   r15 == old(r15);
{
  CalleeSaveLinux();
  // Zero the registers.
  Xor64(rbx,rbx); Xor64(rbp,rbp); Xor64(r12,r12); Xor64(r13,r13); Xor64(r14,r14); Xor64(r15,r15); 
  CalleeRestoreLinux();
} 

// dummy
//procedure {:refined} {:bridge} CalleeSaveRestore() {} 

#verbatim
}
#endverbatim  
